<!-- TOC -->

- [[617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)](#617-合并二叉树httpsleetcode-cncomproblemsmerge-two-binary-trees)
- [[@538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)](#538-把二叉搜索树转换为累加树httpsleetcode-cncomproblemsconvert-bst-to-greater-tree)
- [[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)](#226-翻转二叉树httpsleetcode-cncomproblemsinvert-binary-tree)
- [[@104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)](#104-二叉树的最大深度httpsleetcode-cncomproblemsmaximum-depth-of-binary-tree)
- [[@136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)](#136-只出现一次的数字httpsleetcode-cncomproblemssingle-number)
- [[169. 多数元素](https://leetcode-cn.com/problems/majority-element/)](#169-多数元素httpsleetcode-cncomproblemsmajority-element)
- [[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)](#21-合并两个有序链表httpsleetcode-cncomproblemsmerge-two-sorted-lists)
- [[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)](#283-移动零httpsleetcode-cncomproblemsmove-zeroes)
- [[448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)](#448-找到所有数组中消失的数字httpsleetcode-cncomproblemsfind-all-numbers-disappeared-in-an-array)
- [[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)](#160-相交链表httpsleetcode-cncomproblemsintersection-of-two-linked-lists)
- [[@53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)](#53-最大子序和httpsleetcode-cncomproblemsmaximum-subarray)
- [[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)](#155-最小栈httpsleetcode-cncomproblemsmin-stack)
- [[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)](#1-两数之和httpsleetcode-cncomproblemstwo-sum)
- [[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)](#141-环形链表httpsleetcode-cncomproblemslinked-list-cycle)
- [@[234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)](#234-回文链表httpsleetcode-cncomproblemspalindrome-linked-list)
- [[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)](#20-有效的括号httpsleetcode-cncomproblemsvalid-parentheses)
- [@[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)](#39-组合总和httpsleetcode-cncomproblemscombination-sum)
- [[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)](#22-括号生成httpsleetcode-cncomproblemsgenerate-parentheses)
- [[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)](#105-从前序与中序遍历序列构造二叉树httpsleetcode-cncomproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal)
- [[102. 二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)](#102-二叉树的层次遍历httpsleetcode-cncomproblemsbinary-tree-level-order-traversal)
- [@[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)](#347-前-k-个高频元素httpsleetcode-cncomproblemstop-k-frequent-elements)
- [[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)](#17-电话号码的字母组合httpsleetcode-cncomproblemsletter-combinations-of-a-phone-number)
- [[4. 寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)](#4-寻找两个有序数组的中位数httpsleetcode-cncomproblemsmedian-of-two-sorted-arrays)
- [要再刷一遍](#要再刷一遍)
- [[46. 全排列](https://leetcode-cn.com/problems/permutations/)](#46-全排列httpsleetcode-cncomproblemspermutations)
- [[78. 子集](https://leetcode-cn.com/problems/subsets/)](#78-子集httpsleetcode-cncomproblemssubsets)
- [[@338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)](#338-比特位计数httpsleetcode-cncomproblemscounting-bits)
- [543. [二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)](#543-二叉树的直径httpsleetcode-cncomproblemsdiameter-of-binary-tree)
- [@[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)](#96-不同的二叉搜索树httpsleetcode-cncomproblemsunique-binary-search-trees)
- [[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)](#64-最小路径和httpsleetcode-cncomproblemsminimum-path-sum)
- [[437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)](#437-路径总和-iiihttpsleetcode-cncomproblemspath-sum-iii)
- [[238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)](#238-除自身以外数组的乘积httpsleetcode-cncomproblemsproduct-of-array-except-self)
- [[48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)](#48-旋转图像httpsleetcode-cncomproblemsrotate-image)
- [[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)](#49-字母异位词分组httpsleetcode-cncomproblemsgroup-anagrams)
- [[@739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)](#739-每日温度httpsleetcode-cncomproblemsdaily-temperatures)
- [[@406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)](#406-根据身高重建队列httpsleetcode-cncomproblemsqueue-reconstruction-by-height)
- [[@11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)](#11-盛最多水的容器httpsleetcode-cncomproblemscontainer-with-most-water)
- [[@647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)](#647-回文子串httpsleetcode-cncomproblemspalindromic-substrings)
- [[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)](#198-打家劫舍httpsleetcode-cncomproblemshouse-robber)
- [[@279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)](#279-完全平方数httpsleetcode-cncomproblemsperfect-squares)
- [[75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)](#75-颜色分类httpsleetcode-cncomproblemssort-colors)
- [[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)](#142-环形链表-iihttpsleetcode-cncomproblemslinked-list-cycle-ii)
- [[@@@@@@@394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)](#394-字符串解码httpsleetcode-cncomproblemsdecode-string)
- [[@@337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)](#337-打家劫舍-iiihttpsleetcode-cncomproblemshouse-robber-iii)
- [[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)](#121-买卖股票的最佳时机httpsleetcode-cncomproblemsbest-time-to-buy-and-sell-stock)
- [[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)](#309-最佳买卖股票时机含冷冻期httpsleetcode-cncomproblemsbest-time-to-buy-and-sell-stock-with-cooldown)
- [[@123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)](#123-买卖股票的最佳时机-iiihttpsleetcode-cncomproblemsbest-time-to-buy-and-sell-stock-iii)
- [[@@@621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)](#621-任务调度器httpsleetcode-cncomproblemstask-scheduler)
- [[@@@146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)](#146-lru缓存机制httpsleetcode-cncomproblemslru-cache)
- [[@416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)](#416-分割等和子集httpsleetcode-cncomproblemspartition-equal-subset-sum)
- [[@494. 目标和](https://leetcode-cn.com/problems/target-sum/)](#494-目标和httpsleetcode-cncomproblemstarget-sum)
- [[@300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)](#300-最长上升子序列httpsleetcode-cncomproblemslongest-increasing-subsequence)
- [[@560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)](#560-和为k的子数组httpsleetcode-cncomproblemssubarray-sum-equals-k)
- [[@221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)](#221-最大正方形httpsleetcode-cncomproblemsmaximal-square)
- [[@34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)](#34-在排序数组中查找元素的第一个和最后一个位置httpsleetcode-cncomproblemsfind-first-and-last-position-of-element-in-sorted-array)
- [[240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)](#240-搜索二维矩阵-iihttpsleetcode-cncomproblemssearch-a-2d-matrix-ii)
- [[@79. 单词搜索](https://leetcode-cn.com/problems/word-search/)](#79-单词搜索httpsleetcode-cncomproblemsword-search)
- [[19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)](#19-删除链表的倒数第n个节点httpsleetcode-cncomproblemsremove-nth-node-from-end-of-list)
- [[@322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)](#322-零钱兑换httpsleetcode-cncomproblemscoin-change)
- [[@152. 乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray/)](#152-乘积最大子序列httpsleetcode-cncomproblemsmaximum-product-subarray)
- [[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)](#2-两数相加httpsleetcode-cncomproblemsadd-two-numbers)
- [[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)](#98-验证二叉搜索树httpsleetcode-cncomproblemsvalidate-binary-search-tree)
- [[@31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)](#31-下一个排列httpsleetcode-cncomproblemsnext-permutation)
- [[@33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)](#33-搜索旋转排序数组httpsleetcode-cncomproblemssearch-in-rotated-sorted-array)
- [背包问题的理解](#背包问题的理解)
- [01背包](#01背包)
- [完全背包](#完全背包)
- [多重背包](#多重背包)
- [[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)](#3-无重复字符的最长子串httpsleetcode-cncomproblemslongest-substring-without-repeating-characters)
- [[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)](#5-最长回文子串httpsleetcode-cncomproblemslongest-palindromic-substring)
- [[@15. 三数之和](https://leetcode-cn.com/problems/3sum/)](#15-三数之和httpsleetcode-cncomproblems3sum)
- [[@56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)](#56-合并区间httpsleetcode-cncomproblemsmerge-intervals)
- [[@128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)](#128-最长连续序列httpsleetcode-cncomproblemslongest-consecutive-sequence)
- [[@23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)](#23-合并k个排序链表httpsleetcode-cncomproblemsmerge-k-sorted-lists)
- [[124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)](#124-二叉树中的最大路径和httpsleetcode-cncomproblemsbinary-tree-maximum-path-sum)
- [[@@@239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)](#239-滑动窗口最大值httpsleetcode-cncomproblemssliding-window-maximum)
- [[@84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)](#84-柱状图中最大的矩形httpsleetcode-cncomproblemslargest-rectangle-in-histogram)
- [[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)](#76-最小覆盖子串httpsleetcode-cncomproblemsminimum-window-substring)
- [[@438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)](#438-找到字符串中所有字母异位词httpsleetcode-cncomproblemsfind-all-anagrams-in-a-string)
- [[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)](#200-岛屿数量httpsleetcode-cncomproblemsnumber-of-islands)
- [[@@139. 单词拆分](https://leetcode-cn.com/problems/word-break/)](#139-单词拆分httpsleetcode-cncomproblemsword-break)
- [[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)](#55-跳跃游戏httpsleetcode-cncomproblemsjump-game)
- [@归并排序(mergeSort)](#归并排序mergesort)
- [@快速排序(quickSort)](#快速排序quicksort)
- [@@但凡是有关left,right的函数,一般要判断left>right return](#但凡是有关leftright的函数一般要判断leftright-return)

<!-- /TOC -->

@@的意思是第一次做的不顺利,第二天要再刷一遍

@的意思是第二天刷的比较顺利,考前再刷就好了.



#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```java
改进:
当其中一颗树为空了之后,要学会剪枝
    
public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        TreeNode root;
        if (t1 != null && t2 != null) {
            root = new TreeNode(t1.val + t2.val);
            root.left = mergeTrees(t1.left, t2.left);
            root.right = mergeTrees(t1.right, t2.right);
        } else if (t1 == null && t2 == null) {
            return null;
        } else if (t1 == null) {
            return t2;
        } else {
            return t1;
            //下面的可以剪枝
           // root = new TreeNode(t1.val);
            // root.left = mergeTrees(t1.left,null);
            // root.right = mergeTrees(t1.right,null);
        }
        return root;
    }

改进:非迭代的先序遍历 while(p!=null&&!s.isEmpty()){  在这里访问节点 while(p!=null)p = p.left; }
    中序遍历 while(p!=null&&!s.isEmpty()){   while(p!=null)p = p.left;   } 在后续pop出来的时候访问
	后序遍历比较麻烦.懒得记
    
     public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 != null && t2 != null) {
            stack.push(t2);
            stack.push(t1);
        } else {
            return t1 == null ? t2 : t1;
        }
        while (!stack.isEmpty()) {
            TreeNode s1 = stack.pop();
            TreeNode s2 = stack.pop();
            s1.val = s1.val + s2.val;
            if (s1.left != null && s2.left != null) {
                stack.push(s2.left);
                stack.push(s1.left);
            } else if (s2.left != null) {
                s1.left = s2.left;
            }
            if (s1.right != null && s2.right != null) {
                stack.push(s2.right);
                stack.push(s1.right);

            } else if (s2.right != null) {
                s1.right = s2.right;
            }
        }
        return t1;
    }

```

#### [@538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)



@用迭代来做一下试试

```java
改进:树的非递归中序遍历  
    树的非递归前序遍历与中序遍历的区别是,前序遍历在压栈的时候做节点数据访问;
	树的非递归前序遍历还可以用深度优先搜索的写法,详情看226题翻转二叉树.
//非递归中序遍历变式 (右,根,左)
    private Stack<TreeNode> s = new Stack<TreeNode>();
    private int sum = 0;

    public TreeNode convertBST(TreeNode root) {
        if (root == null)
            return null;
        TreeNode p = root;
        while (!s.isEmpty() || p != null) {
            while (p != null) {
                //前序遍历访问数据处理
                s.push(p);
                p = p.right;
            }
            if (!s.isEmpty()) {
                p = s.pop();
                //中序遍历访问数据处
                sum += p.val;
                p.val = sum;
            }
            p = p.left;
        }
        return root;
    }
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```java
深度优先搜索相当于先序遍历,
广度优先搜索相当于层次遍历.


 //迭代,先序遍历,
    private Stack<TreeNode> s = new Stack<TreeNode>();

    public TreeNode invertTree(TreeNode root) {
        if (root == null)
            return null;
        TreeNode p = root;
        while (!s.isEmpty() || p != null) {
            while (p != null) {
                TreeNode temp = p.right;
                p.right = p.left;
                p.left = temp;

                s.push(p);
                p = p.left;
            }
            if (!s.isEmpty()) {
                p = s.pop();
            }
            p = p.right;
        }
        return root;
    }
```



#### [@104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```java
改进:非递归中序遍历

 private int maxDeep = 0;

    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Stack<DeepTreeNode> stack = new Stack<>();
        TreeNode p = root;
        int deep = 1;
        DeepTreeNode deepNode = new DeepTreeNode(root, 1);
        while (!stack.isEmpty() || p != null) {
            while (p != null) {
                stack.push(new DeepTreeNode(p, deep++));
                p = p.left;
            }
            if (!stack.isEmpty()) {
                DeepTreeNode temp = stack.pop();
                p = temp.node;
                deep = temp.deep;
                maxDeep = Math.max(maxDeep, deep);
            }
            p = p.right;
            deep = deep + 1;
        }
        return maxDeep;
    }
    
树的深度优先遍历,也是树的第二种迭代先序遍历 

private Stack<Pair> s = new Stack<Pair>();
    private int maxDeep = 0;

    public int maxDepth(TreeNode root) {
        if (root == null)
            return maxDeep;
        s.push(new Pair(1, root));
        maxDeep = 1;

        while (!s.isEmpty()) {
            Pair p = s.pop();
            int curDeep = p.deepth;
            maxDeep = Math.max(curDeep, maxDeep);
            TreeNode node = p.node;
            if (node.left != null)
                s.push(new Pair(curDeep + 1, node.left));
            if (node.right != null)
                s.push(new Pair(curDeep + 1, node.right));
        }
        return maxDeep;
    }

    class Pair {
        int deepth;
        TreeNode node;

        Pair(int deepth, TreeNode node) {
            this.deepth = deepth;
            this.node = node;
        }
    }
```

#### [@136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

@异或的办法



```java
思路
1.求差  2(a+b+c) - (a+a+b+b+c)   第一步要求不重复,应该想到用set,Iterator<Integer> i = s.iterator();
2.异或   sum = temp^sum
3.hashMap第一次出现存到map,第二次出现从map里面删除掉
```



#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

```java
public int majorityElement(int[] nums) {
        if (nums == null || nums.length == 0)
            return -1;
        int maxNum = nums[0];
        int count = 1;
        for (int temp : nums) {
            if (temp == maxNum) {
                count++;
            } else {
                count--;
                if (count == 0) {
                    maxNum = temp;
                    count = 1;
                }
            }
        }
        count = 0;
        for (int temp : nums) {
            if (maxNum == temp)
                count++;
        }
        if (count > nums.length / 2)
            return maxNum;
        else
            return -1;
    }
```



#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode last = new ListNode(-1);
        ListNode pHead = last;
        while (l1 != null || l2 != null) {

            if (l1 == null && l2 != null) {
                l1 = l2;
                l2 = null;
            }
            while (l2 == null && l1 != null) {
                ListNode next = l1.next;
                l1.next = last.next;
                last.next = l1;
                l1 = next;
                last = last.next;
            }
            while (l1 != null && l2 != null) {
                ListNode min = null;
                if (l1.val <= l2.val) {
                    min = l1;
                    l1 = l1.next;
                } else {
                    min = l2;
                    l2 = l2.next;
                }
                min.next = last.next;
                last.next = min;
                last = last.next;
            }
        }
        return pHead.next;
    }
```

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

```java
改进:把前面index个位置填满正确的数,最后把index后面的位用0填充
public void moveZeroes(int[] nums) {
        int index = 0;
        for(int temp:nums){
            if(temp!=0){
                nums[index++] = temp;
            }
        }
        for(int i =index;i<nums.length;i++){
            nums[i] = 0;
        }
    }
```

#### [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

```java
改进:
一种意外情况需要考虑   数列: 3,2,3  i=0的时候的3应该放在下标为2的地方,也就是第二个3所在的地方,
但如果一直交换的话,会陷入死循环,所以判断条件里加了一句   nums[i] != nums[index]  ,意思是i所
在位置的值num[i],在index(num[i]-1]处已经存在值num[i]-1了.这个时候不做交换,直接跳过.
                                                                                                                          
  具体来说就是  i=0处 的3应该放在index=2处,但index=2处已经有3了,所以i++,继续往后计算.

public List<Integer> findDisappearedNumbers(int[] nums) {
        ArrayList<Integer> ret = new ArrayList<Integer>();
        for (int i = 0; i < nums.length; ) {
            int index = nums[i] - 1;
            if (index != i && nums[i] != nums[index]) {
                int temp = nums[index];
                nums[index] = nums[i];
                nums[i] = temp;
            } else {
                i++;
            }
        }
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] - 1 != i) {
                ret.add(i + 1);
            }
        }
        return ret;
    }
                                                                                                                                         
方法二:                                                                                                                                         HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    public List<Integer> findDisappearedNumbers(int[] nums) {
        ArrayList<Integer> list = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], 1);
        }
        for (int j = 1; j <= nums.length; j++) {
            if (map.get(j) == null) {
                list.add(j);
            }
        }
        return list;
    }
                                                                                                                                         
                                                                                                                                         改进                                                                                                                               关于map的遍历                                                                                                                         Set<Map.Entry<Integer,Integer>> set = map.entrySet();                                                                                    Iterator<Map.Entry<Integer,Integer>> it = set.iterator();
                                                                                                                                         
```

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```java
 public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int lenA = 0;
        int lenB = 0;
        ListNode pA = headA;
        ListNode pB = headB;
        while (pA != null) {
            lenA++;
            pA = pA.next;
        }
        while (pB != null) {
            lenB++;
            pB = pB.next;
        }
        if (lenB > lenA) {
            int temp = lenA;
            lenA = lenB;
            lenB = temp;
            pA = headB;
            pB = headA;
        } else {
            pA = headA;
            pB = headB;
        }
        for (int i = 1; i <= lenA - lenB; i++) {
            pA = pA.next;
        }
        while (pA != null) {
            if (pA == pB) {
                return pA;
            }
            pA = pA.next;
            pB = pB.next;
        }
        return null;
    }
```

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

```java
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        int[] dp = new int[len];
        dp[0] = nums[0];
        int max = nums[0];
        for (int i = 1; i < len; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            max = Math.max(dp[i], max);
        }
        return max;
    }
```

#### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

```java
	Stack<Integer> realStack = null;
    Stack<Integer> minStack = null;
    private int min = Integer.MAX_VALUE;

    public MinStack() {
        realStack = new Stack<>();
        minStack = new Stack<>();
    }

    public void push(int x) {
        realStack.push(x);
        if (minStack.isEmpty()) {
            minStack.push(x);
        } else {
            if (minStack.peek() < x) {
                minStack.push(minStack.peek());
            } else {
                minStack.push(x);
            }
        }

    }
```

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

```java
这个题没有难度,重点:
1.你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。  只对应一个答案的意思是,只有一对满足要求.
2.如果[3,3] target =6; 判断第二个3跟第一个不同的办法是  map.containsKey(two) && map.get(two) != i
public int[] twoSum(int[] nums, int target) {
        if (nums == null || nums.length <= 1) {
            return new int[]{};
        }
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int two = target - nums[i];

            if (map.containsKey(two) && map.get(two) != i) {
                int twoIndex = map.get(two);
                return new int[]{i, twoIndex};
            }
        }
        return new int[]{};
    }

```

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```java
注意 如果考到这个题,注意看一下需不需要定位环形入口的位置.
    如果需要  则 x+z+y+z  = 2(x+z) ->  y = x
    如果不需要,则用下面的快慢指针即可.


快慢指针法
public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null)
            return false;
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && slow != null) {
            fast = fast.next;
            if (fast == slow)
                return true;
            if (fast != null) {
                fast = fast.next;
            } else {
                return false;
            }
            if (fast == slow)
                return true;
            slow = slow.next;
        }
        return false;
    }

哈希map记录是否访问过
    
    private HashSet<ListNode> set = new HashSet<ListNode>();

    public boolean hasCycle(ListNode head) {
        while (head != null) {
            if (set.contains(head)) {
                return true;
            } else {
                set.add(head);
            }
            head = head.next;
        }
        return false;
    }

```

#### @[234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

@还不熟练,容易出错.

```java
改进:

快慢指针分两种情况
1 2 3 4 5 奇数个: 结束的标志是    fast fast.next=null;fast在5处 slow为3是唯一中点,slow的next为下一半的开始
1 2 3 4	   偶数个: 结束的标志是   fast  fast =null  slow在3处是唯二的靠右边中点,slow即为下一半的开始
public boolean isPalindrome(ListNode head) {
       /* if (head == null) {
            return true;
        }
        if (head.next == null) {
            return true;
        }
        if (head.next.next == null) {
            return head.val == head.next.val;
        }*/
        ListNode slow = head;
        ListNode pre = head;
        ListNode fast = head;
        ListNode leftHead = new ListNode(0);
        while (fast != null && fast.next != null) {
            pre = slow;
            slow = slow.next;

            fast = fast.next.next;

            pre.next = leftHead.next;
            leftHead.next = pre;


        }
        ListNode left = leftHead.next;
        ListNode right = null;
        if (fast == null) {
            right = slow;
        } else {
            right = slow.next;
        }

        while (left != null && right != null) {
            if (left.val != right.val) {
                return false;
            }
            left = left.next;
            right = right.next;
        }
        return true;
    }
```



#### [@20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```java

Stack<Character> stack = new Stack<>();
    HashMap<Character, Character> map = new HashMap<>();

    public boolean isValid(String s) {
        map.put(')', '(');
        map.put('}', '{');
        map.put(']', '[');
        if (s == null || s.length() == 0) {
            return true;
        }
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (stack.isEmpty()) {
                stack.push(chars[i]);
            } else {
                if (map.get(chars[i]) == stack.peek()) {
                    stack.pop();
                } else {
                    stack.push(chars[i]);
                }
            }
        }
        return stack.isEmpty();
    }
```

#### @[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```java
比较规范的回溯写法
    
    
    
    backtracing(path,begin,nums,sum){
    	//终结条件
    if(begin<len){
            
        }
    	if(sum==target){
            
        }
    	if(sum>tartget){
            
        }
    //各种可能
    //其中,传值类的直接加在形参上,如begin+1;地址类的 夹住backtracing,用add()和remove();
    	for(...){
            list.add()
            backtracing(list,begin+1,nums,sum+nums[i]);    
            list.remove()
        }
}


List<List<Integer>> ret = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if (candidates == null || candidates.length == 0) {
            return ret;
        }
        backtracing(candidates, target, 0, 0, path);
        return ret;
    }

    private void backtracing(int[] candidates, int target, int begin, int sum, List<Integer> path) {
        if (begin > candidates.length - 1) {
            return;
        }
        if (sum > target) {
            return;
        }
        if (sum == target) {
            List<Integer> temp = new ArrayList<>(path);
            ret.add(temp);
            return;
        }
        for (int i = begin; i < candidates.length; i++) {
            path.add(candidates[i]);
            backtracing(candidates, target, i, sum + candidates[i], path);
            path.remove(path.size() - 1);
        }
    }


	private List<List<Integer>> ret = new ArrayList<>();
    private List<Integer> list = new ArrayList<>();
    int target = 0;
    int len = 0;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if (candidates == null || candidates.length == 0 || target < 0) {
            return ret;
        }
        len = candidates.length;
        this.target = target;
        backtracing(0, 0, candidates);
        return ret;
    }

    private void backtracing(int begin, int sum, int[] candidates) {
        if (sum == target) {
            ret.add(new ArrayList(list));
        } else if (sum > target) {
            return;
        }
        for (int i = begin; i < len; i++) {
            list.add(candidates[i]);
            backtracing(i, sum + candidates[i], candidates);
            list.remove(list.size() - 1);
        }
    }
```

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

```java
改进:
String的回溯用String的拼接就比较好  temp+"sdf"; 因为String的删除比较麻烦,而StringBuilder的删除也很耗时,如果题目要求返回的是String而不是StringBuilder,那么不要用StringBuilder来做转化.


List<String> ret = new ArrayList<String>();
int max = 0;
public List<String> generateParenthesis(int n) {
    max = n;
    backtracing(0, 0, "");
    return ret;
}

private void backtracing(int left, int right, String temp) {
    if (temp.length() == 2 * max && left == right) {
        ret.add(temp);
        return;
    }
    if (left >= right && left <= max) { //只有左括号没有超出max;左括号大于等于左括号的个数的时候,才有必要尝试下去(剪枝)
        backtracing(left + 1, right, temp + "(");
        backtracing(left, right + 1, temp + ")");
    }
}
```



#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
 public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }

    private TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {
        if (preStart > preEnd || inStart > inEnd || preStart < 0 || preEnd >= preorder.length || inStart < 0 || inEnd >= inorder.length) {
            return null;
        }
        int rootVal = preorder[preStart];
        int cutIndex = 0;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == rootVal) {
                cutIndex = i;
                break;
            }
        }
        int leftLen = cutIndex - inStart;
        TreeNode root = new TreeNode(rootVal);
        root.left = buildTree(preorder, preStart + 1, preStart + leftLen, inorder, inStart, cutIndex - 1);
        root.right = buildTree(preorder, preStart + leftLen + 1, preEnd, inorder, cutIndex + 1, inEnd);
        return root;
    }
```



#### [102. 二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)



```java
改进:
思路有 1. 层次遍历(每层入队列的时候记录下一层有多少个子节点)for (int i = 0; i < levelCount; i++)
      2.深度优先遍历(先根遍历)

//层次遍历源码
Queue<TreeNode> queue = new LinkedList<TreeNode>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ret = new ArrayList<>();
        if (root == null) {
            return ret;
        }
        queue.add(root);
        int levelCount = 1;

        while (!queue.isEmpty()) {
            List<Integer> list = new ArrayList<Integer>();
            int temp = 0;
            for (int i = 0; i < levelCount; i++) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if (node.left != null) {
                    queue.add(node.left);
                    temp++;
                }
                if (node.right != null) {
                    queue.add(node.right);
                    temp++;
                }
            }
            levelCount = temp;
            ret.add(list);
        }
        return ret;
    }


//深度优先源码

List<List<Integer>> ret = new ArrayList<>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return ret;
        }
        preOrder(root, 0);

        return ret;

    }

    private void preOrder(TreeNode root, int level) {
        if (root == null) {
            return;
        }
        List<Integer> temp = null;
        if (ret.size() <= level) {
            temp = new ArrayList<Integer>();
            ret.add(temp);
        }
        temp = ret.get(level);
        temp.add(root.val);
        preOrder(root.left, level + 1);
        preOrder(root.right, level + 1);
    }
```



#### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)



@基本方法已经掌握了,注意他这里的一个技巧. 他的优选队列里面存的是num而非frequency. num的比较用的是 

Comparator<Integer> c = new Comparator<Integer>() {
            public int compare(Integer i1, Integer i2) {
                return map.get(i1) - map.get(i2);
            }
        };

内部的比价器居然可以用外部的map.



```java
改进:
map来记录出现次数
小顶堆来记录topk

注意比较器的写法:return map.get(i1) - map.get(i2);
注意k不能决定堆得最大容量,堆会自动扩容,所以要在add元素进堆得时候进行大小判断,如果size()>k,则add之后poll一个出来


    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    public List<Integer> topKFrequent(int[] nums, int k) {
        Comparator<Integer> c = new Comparator<Integer>() {
            public int compare(Integer i1, Integer i2) {
                return map.get(i1) - map.get(i2);
            }
        };
        PriorityQueue<Integer> heap = new PriorityQueue<Integer>(k, c);
        for (int temp : nums) {
            if (map.get(temp) == null) {
                map.put(temp, 1);
            } else {
                map.put(temp, map.get(temp) + 1);
            }
        }
        Set<Map.Entry<Integer, Integer>> s = map.entrySet();
        Iterator<Map.Entry<Integer, Integer>> i = s.iterator();
        while (i.hasNext()) {
            if (heap.size() < k) {
                heap.add(i.next().getKey());
            } else {
                heap.add(i.next().getKey());
                heap.poll();
            }
        }
        List<Integer> list = new ArrayList<Integer>();
        while (!heap.isEmpty()) {
            list.add(heap.poll());
        }
        return list;
    }
```



#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```java
回溯,没啥好说的

Map<String, String> numsAndLetters = new HashMap<String, String>() {{
    put("2", "abc");
    put("3", "def");
    put("4", "ghi");
    put("5", "jkl");
    put("6", "mno");
    put("7", "pqrs");
    put("8", "tuv");
    put("9", "wxyz");
}};
List<String> ret = new ArrayList<String>();
int len = 0;
public List<String> letterCombinations(String digits) {
    if (digits == null || digits.length() == 0) {
        return ret;
    }
    len = digits.length();
    backtracing(0, "", digits);
    return ret;
}

private void backtracing(Integer index, String path, String digits) {
    if (index == len) {
        ret.add(path);
        return;
    }
    String numLetters = numsAndLetters.get(digits.substring(index, index + 1));
    for (int i = 0; i < numLetters.length(); i++) {
        String temp = numLetters.substring(i, i + 1);
        backtracing(index + 1, path + temp, digits);
    }
}
```



#### [4. 寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

```java
思路1: 把两个数组合并,然后寻找中位数.

public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    if (nums1 == null || nums2 == null) {
        return 0;
    }
    int m = nums1.length;
    int n = nums2.length;
    int[] allNums = new int[m + n];
    int count = 0;
    int i = 0;
    int j = 0;
    while (i < m && j < n && count < m + n) {
        if (nums1[i] < nums2[j]) {
            allNums[count++] = nums1[i++];
        } else {
            allNums[count++] = nums2[j++];
        }
    }
    while (i < m) {
        allNums[count++] = nums1[i++];
    }
    while (j < n) {
        allNums[count++] = nums2[j++];
    }
    if (count % 2 == 0) {
        return ((double) allNums[count / 2] + (double) allNums[count / 2 - 1]) / 2;
    } else {
        return allNums[count / 2];
    }
}
```

































#### 要再刷一遍



#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```java
改进  典型的回溯法问题,一定要熟练掌握.

private List<List<Integer>> ret = new ArrayList<>();
boolean[] visited;
private List<Integer> path = new ArrayList<>();

public List<List<Integer>> permute(int[] nums) {
    int len = nums.length;
    visited = new boolean[len];
    backtracing(nums);

    return ret;
}

private void backtracing(int[] nums) {
    if (path.size() == nums.length) {
        ret.add(new ArrayList(path));
    }
    for (int i = 0; i < nums.length; i++) {
        if (visited[i])
            continue;

        path.add(nums[i]);
        visited[i] = true;
        backtracing(nums);
        visited[i] = false;
        path.remove(path.size() - 1);
    }

}
```

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

```java
   List<List<Integer>> ret = new ArrayList<>();
    ArrayList<Integer> list = new ArrayList<>();
    int len = 0;

    public List<List<Integer>> subsets(int[] nums) {
        len = nums.length;
        backtracing(0, nums);
        return ret;
    }

    private void backtracing(int begin, int[] nums) {
        ret.add(new ArrayList(list));
        for (int i = begin; i < len; i++) {
            list.add(nums[i]);public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0 || nums.length < k) {
            return new int[]{};
        }
        Comparator<Integer> c = new Comparator<Integer>() {
            public int compare(Integer i1, Integer i2) {
                return nums[i2] - nums[i1];
            }
        };
        ArrayList<Integer> ret = new ArrayList<>();
        PriorityQueue<Integer> heap = new PriorityQueue<Integer>(10, c);
        int right = 0;
        int len = nums.length;
        for (right = 0; right <= len; right++) {
            if (right < k) {
                heap.add(right);
                continue;
            }
            ret.add(nums[heap.peek()]);
            heap.remove(right - k);
            if (right < len) {
                heap.add(right);
            }
        }
        int[] retArray = new int[ret.size()];
        for (int i = 0; i < ret.size(); i++) {
            retArray[i] = ret.get(i);
        }
        return retArray;
    }
            backtracing(i + 1,nums);
            list.remove(list.size()-1);
        }
    }
```

#### [@338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

@思路没想到

```java
改进 动态规划的方法
    0 可以得出 1               2^0
    0 和 1 能得出  2 和 3       2^1
    0 1 2 3 能得出  4 5 6 7    2^2
public int[] countBits(int num) {
        int[] ans = new int[num + 1];
        ans[0] = 0;
        int b = 1;
        int i = 0;
        while (b <= num) {
            while (i < b && b + i <= num) {
                ans[b + i] = ans[i] + 1;
                i++;
            }
            b <<= 1;

            i = 0;
        }
        return ans;
    }
```





#### 543. [二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)



```java
改进: 先根遍历/也是深度优先搜索 ,每个root求左右子树长度之和,注意最终的直径也许不会经过根节点,比如
      2
    3   1
  6  4
  9
  8
private int maxLength = Integer.MIN_VALUE;

    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null)
            return 0;
        preOrder(root);
        return maxLength;
    }

    private int preOrder(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int lenL = preOrder(root.left);
        int lenR = preOrder(root.right);
        int length = lenL + lenR; //root不算在总长度里面
        maxLength = Math.max(maxLength, length);
        return Math.max(lenL, lenR) + 1;
    }
```



#### @[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

```java
改进: 从1~n,每个节点都可以当根来组成二叉搜索树.
    如果1是根,则左右两边的节点数分别是0,n-1;能组成的搜索树个数为:dp[0]*dp[n-1]
    如果2是根,则左右两边的节点数分别是1,n-2;能组成的搜索树个数为:dp[1]*dp[n-2]
    所以第一个循环是从i=2求到i=n的dp[n]有多少种搜索树的组成
    第二个循环是在求dp[i]的1~分别当根节点,组成的搜索树个数

public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
```



#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```java
	如果是求和,用动规. 如果求path的具体内容比如匹配路径字符串(abcd)则用回溯

改进:用回溯法会超时;不过注意回溯法的用法:
	不要用xy   x和y在数组的申请和定位数据的时候是反直觉的grid[y][x] new int[yBound][xBound]
    用row col  row和col的含义是第几row和 第几col
    grid[row][col] new int [row][col]    
    
    
    boolean[][] visited = null;
    int min = Integer.MAX_VALUE;
    int[][] loc = new int[][]{{1, 0}, {-1, 0}, {0, -1}, {0, 1}};
    int path = 0;
    int targetRow = 0;
    int targetCol = 0;

    public int minPathSum(int[][] grid) {
        int rowCount = grid.length;
        int colCount = grid[0].length;
        targetRow = rowCount - 1;
        targetCol = colCount - 1;
        visited = new boolean[rowCount][colCount];
        visited[0][0] = true;
        path = grid[0][0];
        backtracing(grid, path, 0, 0);
        return min;
    }

    private void backtracing(int[][] grid, int path, int row, int col) {

        if (row == targetRow && col == targetCol) {
            min = Math.min(min, path);
        }
        for (int i = 0; i < loc.length; i++) {
            col = col + loc[i][1];
            row = row + loc[i][0];
            if (!(row < 0 || col < 0 || row > targetRow || col > targetCol || visited[row][col] == true)) {
                visited[row][col] = true;
                backtracing(grid, path + grid[row][col], row, col);
                visited[row][col] = false;
            }
            col = col - loc[i][1];
            row = row - loc[i][0];
        }
    }


改进:动态规划的做法
    状态转移方程: dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))
        
    时间复杂度O(mn)已经无法优化,空间复杂度O(mn)可以优化为O(1),就是用grid本身来做dp.
    
    public int minPathSum(int[][] grid) {
        int rowCount = grid.length;
        int colCount = grid[0].length;
        int[][] dp = new int[rowCount][colCount];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < rowCount; i++) {
            dp[i][0] = grid[i][0] + dp[i - 1][0];
        }
        for (int j = 1; j < colCount; j++) {
            dp[0][j] = grid[0][j] + dp[0][j - 1];
        }
        for (int i = 1; i < rowCount; i++) {
            for (int j = 1; j < colCount; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[rowCount - 1][colCount - 1];
    }
```



#### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

```java
改进:双递归的题,有点难度.
    pathSum的递归用于遍历所有节点,根节点是不断变化的
    pathFromRoot的递归用于找到一条root为根节点,root的子节点为终止节点的路径

public int pathSum(TreeNode root, int sum) {
        if (root == null) {
            return 0;
        }
        return pathFromRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    }

    private int pathFromRoot(TreeNode root, int sum) {
        if (root == null) {
            return 0;
        }
        int ret = 0;
        if (root.val == sum) {
            ret = 1;
        }
        ret += pathFromRoot(root.left, sum - root.val);
        ret += pathFromRoot(root.right, sum - root.val);
        return ret;
    }
```



#### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

```java
改进:空间复杂度O(1) 要么是在ret上做累加,要么是原数组nums上做修改
	时间复杂度O(n)必然是之前计算的结果可以拿到后面用.
	ret[i] 等于nums的 i左边的数 乘以 i右边的数
public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        int[] ret = new int[len];
        ret[0] = 1;
        for (int i = 1; i < len; i++) {
            ret[i] = ret[i - 1] * nums[i - 1];
        }
        int temp = 1;
        for (int i = len - 1; i >= 0; i--) {
            ret[i] = ret[i] * temp;
            temp = temp * nums[i];
        }
        return ret;
    }
```

#### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

```java
改进: 先转置,在镜像翻转  =  往右旋转九十度

public void rotate(int[][] matrix) {
        int len = matrix.length;
        //转置
        for (int i = 0; i < len; i++) {
            for (int j = i + 1; j < len; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        //镜像翻转
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len / 2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][len - j - 1];
                matrix[i][len - j - 1] = temp;
            }
        }
    }
```

#### [@@@49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

方法1:下面代码:

方法2: a 对应0  b对应1  c对应2.....

int[] prime = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103 };

例如 abc ，就对应 'a' - 'a'， 'b' - 'a'， 'c' - 'a'，即 0, 1, 2，也就是对应素数 2 3 5，然后相乘 2 * 3 * 5 = 30，就把 "abc" 映射到了 30。

方法3: 

首先初始化 key = "0#0#0#0#0#"，数字分别代表 abcde 出现的次数，# 用来分割。

这样的话，"abb" 就映射到了 "1#2#0#0#0"。

"cdc" 就映射到了 "0#0#2#1#0"。

"dcc" 就映射到了 "0#0#2#1#0"。

1. 用一个cout[]数组记录每个字符串中每个字母出现的次数
2. key用StringBuilder来维护,把一个count[]数组append进key里面
3. 把key作为map的key



```java
改进:
每个字符串"cba" 用排序之后的"abc"作为key存储在HashMap<String, ArrayList<String>>;
key相同的字符串放在map的value即ArrayList里面

public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();
        for (int i = 0; i < strs.length; i++) {
            String str = strs[i];
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String strSort = new String(chars);

            if (map.get(strSort) == null) {
                ArrayList<String> list = new ArrayList<String>();
                list.add(str);
                map.put(strSort, list);
            } else {
                ArrayList<String> list = map.get(strSort);
                list.add(str);
                map.put(strSort, list);
            }
        }
        List<List<String>> ret = new ArrayList<>();
        Set<Map.Entry<String, ArrayList<String>>> s = map.entrySet();
        Iterator<Map.Entry<String, ArrayList<String>>> it = s.iterator();
        while (it.hasNext()) {
            ret.add(it.next().getValue());
        }
        return ret;
    }

```



#### [@739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

@此题栈的使用太巧秒了

栈里面存的是升序的,比T[i]处温度大的一些温度.

```java
改进:逆序遍历,记录以往的温度的最大值,因为如果 倒数第二天温度是75, 最后一天温度是70,则倒数第三天的时候如果温度是76比75大,则继续往后找也找不到比76大的天气了,因为75是未来几天最大的温度.

public int[] dailyTemperatures(int[] T) {
        Stack<Integer> stack = new Stack<>();
        int len = T.length;
        int[] ret = new int[len];
        for (int i = len - 1; i >= 0; i--) {
            int temp = T[i];
            while (!stack.isEmpty()) {
                if (temp >= T[stack.peek()]) {
                    stack.pop();
                } else {
                    ret[i] = stack.peek() - i;
                    break;
                }
            }
            stack.push(i);
        }
        return ret;
 }

改进:获取比当前温度temp高的所有温度的日期,找距离当前日期最近的那个

public int[] dailyTemperatures(int[] T) {
        int len = T.length;
        int[] ans = new int[len];
        int[] next = new int[101];
        for (int i = len - 1; i >= 0; i--) {
            int temp = T[i];
            next[temp] = i;
            int warmerIndex = Integer.MAX_VALUE;
            ans[i] = 0;
            for (int j = temp + 1; j <= 100; j++) {
                if (next[j] != 0) {
                    warmerIndex = Math.min(next[j], warmerIndex);
                    ans[i] = warmerIndex - i;
                }
            }

        }
        return ans;
    }
```



#### [@406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

```java
改进:先根据身高从大到小,k从小到大来排数组,然后将排好序的数组往另一个数组里插入,插完就是想要的结果
public int[][] reconstructQueue(int[][] people) {
    Comparator c = new Comparator<int[]>() {
        public int compare(int[] o1, int[] o2) {
            return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0];
        }
    };
    Arrays.sort(people, c);
    ArrayList<int[]> list = new ArrayList<>();
    for (int[] temp : people) {
        list.add(temp[1], temp);
    }
    return list.toArray(new int[list.size()][2]);
}
```





#### [@11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)



@受制于短的,所以每次移动短的.

```java
改进:
思路是双指针法,左右两边的指针往中间移动
public int maxArea(int[] height) {
    int left = 0;
    int right = height.length - 1;
    int maxArea = 0;
    while (left < right) {
        maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left));
        if (height[left] > height[right]) {
            right--;
        } else {
            left++;
        }
    }
    return maxArea;
}
```



#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

```java
改进:动态规划类的题目,找好状态转义方程+定好不满足方程的边界条件就可以解出来


dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); 第i天的收获 = Max(昨天,前天+今天);
关于边界处的思考: dp[0] = nums[0];dp[1] = Math.max(nums[0], nums[1]);也就是说dp[1]可以是nums[0]也可以是nums[1],我会有疑惑: 如果dp[1]选的是nums[0],那dp[2]在选dp[1]=nums[0]的时候还有必要隔一天吗?直接dp[2]=dp[1]+nums[2]不就好了
    
事实上,dp[1] =  nums[0]  或  nums[1]
     dp[2] =  max(dp[1],dp[0]+nums[2])分下面两种情况
    当dp[1] = nums[1]时
		max(dp[1],dp[0]+nums[2])其实是  nums[1] 和 nums[0]+nums[2]比较大小
     当dp[1] = nums[0]时
    	 max(dp[1],dp[0]+nums[2])其实是  nums[0] 和 nums[0]+nums[2]比较大小;该情况下必选dp[0]+nums[2],所以上面疑惑的那种情况出现的时候,选dp[1]+nums[2](也就是dp[0]+nums[2])而非dp[1]是必然的,而且能满足隔一个房间.

public int rob(int[] nums) {
    int len = nums.length;
    if (len == 0)
        return 0;
    if (len == 1) {
        return nums[0];
    }
    int[] dp = new int[len];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for (int i = 2; i < len; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[len - 1];
}
```

#### [@@@279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

一维的,从小到大,但是不相邻的动态规划

@思考 什么样的问题用动规解决比较好 (从小到大的累计过程用动规比较好)

本题的动规方程为啥没想到.

```java
改进:状态转移方程 dp[i] = Math.min(dp[i],dp[i-1],dp[i-4],dp[i-16],dp[i-j*j])

public int numSquares(int n) {
    int[] dp = new int[n + 1];
    for (int i = 1; i <= n; i++) {
        dp[i] = i;
        for (int j = 1; i - j * j >= 0; j++) {
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
        }
    }
    return dp[n];
}


```

#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

```java
改进:统计每个颜色有几个,然后填到数组中

//借助常数空间意味着在原来的数组上改动,并且用temp之类的变量来记录信息
    public void sortColors(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int temp : nums) {
            if (map.get(temp) == null) {
                map.put(temp, 1);
            } else {
                map.put(temp, map.get(temp) + 1);
            }
        }
        int color = -1;
        int colorCount = 0;
        for (int i = 0; i < nums.length; ) {
            if (colorCount > 0) {
                nums[i++] = color;
                colorCount--;
            } else {
                color++;
                if (map.get(color) == null) {
                    colorCount = 0;
                } else {
                    colorCount = map.get(color);
                }
            }
        }
    }

改进: 思路  left->   cur->   <-right
 //常数空间(用一些小数据记录信息,temp交换数据))+一趟遍历(修改原数组)
    public void sortColors(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        int cur = 0;
        while (cur <= right) {
            if (nums[cur] == 0) {
                int temp = nums[cur];
                nums[cur] = nums[left];
                nums[left] = temp;
                left++;
                cur++;//left++的时候cur++是因为cur是从左边开始往右走,
                //如果left++,代表cur的左边界往右走去了.这个时候cur++就又回到了左边界最开始的地方
            } else if (nums[cur] == 2) {
                int temp = nums[cur];
                nums[cur] = nums[right];
                nums[right] = temp;
                right--;
            } else {
                cur++;
            }
        }
    }
```



#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

```java
改进:公式  x + y+ z + y = 2(x+y)推出  x = z 所以这个时候把快指针放到phead处,走x;慢指针走z;两个指针就会在
    环入口处相遇
    
    注意代码的逻辑上有几个要注意的问题
     while (fast != null && fast.next != null) {//走两步必备的判空
         
     if (fast == null || fast.next == null) {  //如果fast是因为空指针跳出while循环则不存在环
        return null;
    }

public ListNode detectCycle(ListNode head) {
    if (head == null) {
        return null;
    }
    if (head.next == null) {
        return null;
    }
    ListNode fast = head;
    ListNode slow = head;
    while (fast != null && fast.next != null) {//走两步必备的判空
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            break;
        }
    }
    if (fast == null || fast.next == null) {  //如果fast是因为空指针跳出while循环则不存在环
        return null;
    }
    fast = head;
    while (fast != slow) {                  //如果fast不是因为空指针跳出while循环,fast和slow分别在
        									//走了x 和 z步后相遇(x=z)
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```

#### [@@@@@@@394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)



@@//字母 数字  [  ] 四种情况   +

  stringbuilder的应用 +

栈的应用,括号类问题的处理

```java
改进:代码太牛,记住就好
public String decodeString(String s) {
        StringBuilder curStr = new StringBuilder();
        int curCount = 0;
        Stack<StringBuilder> stack_str = new Stack<StringBuilder>();
        Stack<Integer> stack_num = new Stack<Integer>();
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (ch == '[') {
                stack_str.push(curStr);
                stack_num.push(curCount);
                curStr = new StringBuilder();
                curCount = 0;
            } else if (ch == ']') {
                StringBuilder temp = new StringBuilder();
                int count = stack_num.pop();
                for (int j = 0; j < count; j++) {
                    temp.append(curStr.toString());
                }
                curStr = stack_str.pop();
                curStr.append(temp);
            } else if (ch >= '0' && ch <= '9') {
                curCount = curCount * 10 + ch - '0';
            } else if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z')) {
                curStr.append(ch);
            }
        }
        return curStr.toString();
    }
```





#### @@@@@动态规划类题目的反思



1. 明确末尾return的是boolean还是 int 这决定了dp里面存的是啥
2. 然后确定dp是二维还是一维.最终状态由多少个维度决定
    1. 比如目标和类的题目.因为`dp[i][S]中S`可能由多种前状态得出,所以需要第二维来记录值.
    2. 比如最大子序列,只需要len一个状态
    3. 交易次数的股票: i天数  k 交易次数  0 1 是否持有股票
3. 然后明确状态转移方程 
    1. 如果是必须要加减nums[i].则
        `dp[i][j] = dp[i-1][j-nums[i]] || dp[i-1][j+nums[i]];`
    2. 如果是可以抛弃当前nums[i]
        `dp[i][j] = dp[i-1][j]||dp[i-1][j-nums[i]];`
    3. 如果是涉及最大值问题(比如最大上升子序列)
        dp[i]代表到i的时候,最长序列是啥
        dp[i] = Math.max(dp[i],dp[j]+1)  
4. **同时注意状态转移的条件和各种状态的初始化**比如最大上升子序列:初始化dp[i]= 1 和  nums[i]>=nums[j]的条件.比如兑换硬币类的题目,dp[i]最多可以被1兑换成i个,所以dp[i]初始化为i.



#### [@@@@337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)



改进:树的后续遍历+动态规划

```java

HashMap<TreeNode, Integer> memo = new HashMap<TreeNode, Integer>();

public int rob(TreeNode root) {
    if (root == null) {
        return 0;
    }
    lastOrder(root);
    return memo.get(root);
}

private int lastOrder(TreeNode root) {
    if (root == null) {
        return 0;
    }

    if (memo.containsKey(root)) return memo.get(root);
    int money1 = root.val;
    int money2 = 0;
    int maxMoney = 0;
    if (root.left != null) {
        money2 += lastOrder(root.left);
        money1 += lastOrder(root.left.left);
        money1 += lastOrder(root.left.right);

    }
    if (root.right != null) {
        money2 += lastOrder(root.right);
        money1 += lastOrder(root.right.left);
        money1 += lastOrder(root.right.right);

    }
    maxMoney = Math.max(money1, money2);
    memo.put(root, maxMoney);
    return maxMoney;
}
```

#### [@@@@@@121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

@/0-prices[i]而非dp[i-1][1]-prices[i]是为了防止多次买卖,

```java
 public int maxProfit(int[] prices) {
        if (prices == null || prices.length <= 1) {
            return 0;
        }
        int len = prices.length;
        int[][] dp = new int[len + 1][2];
        dp[1][0] = 0;
        dp[1][1] = -prices[0];
        for (int i = 2; i <= len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1]);
              //0-prices[i]而非dp[i-1][1]-prices[i]是为了防止多次买卖,
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i - 1]);
        }
        return dp[len][0];
    }
          
```



#### [@@@309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

改进:动态规划类的题目:1.找状态和选择2.定好base_case 就这两点而已,详情看下面大神题解
    https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/

```java
改进后: 
public int maxProfit(int[] prices) {
        if (prices == null || prices.length <= 1) {
            return 0;
        }
        int len = prices.length;
        int[][] dp = new int[len + 1][2];
        dp[1][0] = 0;
        dp[1][1] = -prices[0];

        for (int i = 2; i <= len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1]);
            //i-2其实这里要对i=2 时候  dp[0][0]的边界关注一下,好处是dp[0][0]=0
            //依然符合状态转移方程
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i - 1]);
        }
        return dp[len][0];
    }



改进前:

 public int maxProfit(int[] prices) {
        if (prices == null) {
            return 0;
        }
        int len = prices.length;
     
        if (len <= 1) {
            return 0;
        }
        int[][] dp = new int[len + 1][2];
     	//第一天初始化	
        dp[1][0] = 0;
        dp[1][1] = -prices[0];
		//第二天初始化,因为第二天不能用  dp[i - 2][0] - prices[i - 1]   (其实也可以用,因为用dp[0][0]=0)
     	dp[2][0] = Math.max(dp[1][0], dp[1][1] + prices[1]);
        dp[2][1] = Math.max(dp[1][1], dp[1][0] - prices[1]);
     	//从第三天开始可以用状态转移方程
        for (int i = 3; i <= len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i - 1]);
        }
        return dp[len][0];
    }
```



#### [@@@123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)





```java
@@@
1.关于i=0时的边界条件
dp[0][k][0] = 0;
dp[0][k][1] = -prices[0];
无论k为0,1,2这个赋值都成立.
2.列出状态转移方程:
k代表的是剩余交易次数.每次卖出股票后,算消耗了一次交易次数.
if (k - 1 >= 0) {
     dp[i][k - 1][0] = Math.max(dp[i - 1][k - 1][0], dp[i - 1][k][1] + prices[i]);
 }
dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k][0] - prices[i]);

```



```java
public int maxProfit(int[] prices) {
        if (prices == null || prices.length <= 1) {
            return 0;
        }
        int len = prices.length;
        int[][][] dp = new int[len + 1][3][2];
        dp[1][2][1] = Integer.MIN_VALUE;
        dp[1][2][0] = 0;
        dp[1][1][1] = -prices[0];
        dp[1][1][0] = 0;
        dp[1][0][1] = -prices[0];
        dp[1][0][0] = 0;
        //卖出时记录消耗一笔
        for (int i = 2; i <= len; i++) {
            for (int k = 0; k <= 2; k++) {
                //dp[i][k][1]里面的k取值为 0 1   2是不行的,所以设为minvalue
                //因为dp[i][k][0]会用到dp[i][2][1].所以先设置dp[i][2][1];在计算dp[i][k][0]
                if (k == 2) {
                    dp[i][2][1] = Integer.MIN_VALUE;
                } else if (k <= 1) {
                    dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k + 1][0] - prices[i - 1]);
                }
                //dp[i][k][0]里面的k取值为 0 1 2
                dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i - 1]);
            }
        }
        return dp[len][0][0];
    }
```

#### [@621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)

@优先队列,来确定执行顺序

@每个n为一个轮回,既可以解决空转,又可以让数量多的任务先运行



```java
改进:
容易出错的地方:
1.当queue是空并且list里面也没有候选,要提前退出,cpu不需要走完完整的一个轮回(n+1)个任务
    if (frequencyOfChar.isEmpty() && frequencyDcreByOneList.size() == 0)
                    break;

public int leastInterval(char[] tasks, int n) {
        HashMap<Character, Integer> freqCount = new HashMap<>();
        PriorityQueue<Integer> freqQueue = new PriorityQueue<Integer>(10, (o1, o2) -> (o2 - o1));
        for (int i = 0; i < tasks.length; i++) {
            char ch = tasks[i];
            if (freqCount.containsKey(ch)) {
                freqCount.put(ch, freqCount.get(ch) + 1);
            } else {
                freqCount.put(ch, 1);
            }
        }
        Iterator<Map.Entry<Character, Integer>> it = freqCount.entrySet().iterator();
        while (it.hasNext()) {
            freqQueue.add(it.next().getValue());
        }
        int timeCount = 0;
        while (true) {
            List<Integer> ready = new ArrayList<Integer>();
            for (int i = 0; i <= n; i++) {
                if (!freqQueue.isEmpty()) {
                    int max = freqQueue.poll();
                    max--;
                    if (max >= 1) {
                        ready.add(max);
                    }
                }
                timeCount++;
                if (freqQueue.isEmpty() && ready.size() == 0) {
                    return timeCount;
                }
            }
            for (int j = 0; j < ready.size(); j++) {
                freqQueue.add(ready.get(j));
            }
        }
    }

```

#### [@@@146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)

@双向链表的做法.

```java
改进:LinkedHashMap 可以在构造的时候指定,是否按照访问顺序来存储节点(key)
    访问的时候,从链表中拿到key,在用key从map中拿到value

   
    
    思路1:
    class LRUCache {
        private LinkedHashMap<Integer, Integer> map;

        public LRUCache(int capacity) {
            map = new LinkedHashMap<Integer, Integer>(capacity, 0.75F, true) {
                public boolean removeEldestEntry(Map.Entry<Integer, Integer> entry) {
                    return size() > capacity;
                }
            };
        }

        public int get(int key) {
            return map.getOrDefault(key, -1);
        }

        public void put(int key, int value) {
            map.put(key, value);
        }
    }


思路2:  有个弊端,list.remove的时候复杂度是O(n)	另外注意list.remove((Object)key)  和 remove.(Index)
class LRUCache {
        LinkedList<Integer> list = null;
        HashMap<Integer, Integer> map = null;
        int cap = 0;

        public LRUCache(int capacity) {
            list = new LinkedList<>();
            map = new HashMap<>();
            this.cap = capacity;
        }

        public int get(int key) {
            Integer val = map.get(key);
            if (val != null) {
                list.remove((Object) key);
                list.addLast(key);
                return val;
            }
            return -1;
        }

        public void put(int key, int value) {
            Integer val = map.get(key);
            if (val != null) {
                list.remove((Object) key);
                list.addLast(key);
                map.put(key, value);
                return;
            }
            if (list.size() < cap) {
                list.addLast(key);
                map.put(key, value);
            } else {
                Integer firstKey = list.getFirst();
                map.remove(firstKey);
                list.removeFirst();
                map.put(key, value);
                list.addLast(key);
            }
        }
    }
```

#### [@@@416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)







```java
改进:01背包问题
public boolean canPartition(int[] nums) {
    int sum = 0;
    for (int temp : nums) {
        sum += temp;
    }
    int target = sum / 2;
    if (sum % 2 == 1) {
        return false;
    }
    boolean[][] dp = new boolean[nums.length][target + 1];
    if (nums[0] <= target) {
        dp[0][nums[0]] = true;
    }
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j <= target; j++) {
            //如果j为0,记得把选择(要还是不要)第i个物品后,恰好总和为0的情况设置为true
            //只要一个都不选,则dp[i][0]永远为true
            //设置成true是为了 nums[i]==j的时候用
            if (j == 0) {
                dp[i][j] = true;
                continue;
            }
            //只有nums[i]<=j的时候,背包的总和才有可能刚好等于j
            if (nums[i] <= j) {
                //状态转移方程
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
            }
        }
    }
    return dp[nums.length - 1][target];
}
```



4. 若temp.charAt(0)=='0'只能为一位0不能是001,012,08这种类型.

背包类的动态规划,跟  分割等和子集 是一类题目.  i处选不选物品 由i-1处决定.



```java
改进:背包问题
    对于sum为负数的dp[i][sum],用dp[i][sum+1000]来解决负数
 public int findTargetSumWays(int[] nums, int S) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        //在最底部的return的时候,考虑到数组越界的问题
        if (S < -1000 || S > 1000) {
            return 0;
        }
        int len = nums.length;
        int deta = 1000;
        //realsum + deta  = dp[][x]
        // realSum 为-1000~1000
        //realSum+deta 为 0~2000
        int[][] dp = new int[len][2001];
        //nums[0]=0时,用++ 比用 dp[0][deta - nums[0]]=1要好
        dp[0][deta + nums[0]]++;
        dp[0][deta - nums[0]]++;
        for (int i = 1; i < len; i++) {
            int temp = nums[i];
            for (int j = 0; j <= 2000; j++) {
                if (dp[i - 1][j] != 0) {
                    dp[i][j - nums[i]] += dp[i - 1][j];
                    dp[i][j + nums[i]] += dp[i - 1][j];
                }
            }
        }
        return dp[len - 1][S + deta];
    }
```

#### [@@@300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

@dp[i]要赋值为1

@状态转移方程 想不到.

比较好的解释:https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/man-hua-ti-jie-zai-ben-du-neng-kan-de-dong-de-dong/



```java
  public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length < 1) {
            return 0;
        }
        int len = nums.length;
        int[] dp = new int[len + 1];
        dp[1] = 1;
        int max = 1;
        for (int i = 2; i <= len; i++) {
            dp[i] = 1;
            for (int j = 1; j < i; j++) {
                if (nums[i - 1] > nums[j - 1]) {
                    dp[i] = Math.max(dp[j] + 1, dp[i]);
                    max = Math.max(dp[i], max);
                }
            }
        }
        return max;
    }
```



#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

@很容易想到梯度,但是没想到sum-k的形式.





```java
改进: map.put(0,1)放入,是为了sum本身就等于 k,即 sum-k = 0;
		map中先搜索sum-k再放入sum   是为了防止k=0的情况,此时先放入sum-0,再搜索sum,是一种混淆. 本身sum放入map是给下一次累加的sum使用的,而非本次累加.

HashMap<Integer, Integer> map = new HashMap<>();
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        int sum = 0;
        map.put(0, 1);
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (map.containsKey(sum - k)) {
                count += map.get(sum - k);
            }
            if (map.containsKey(sum)) {
                map.put(sum, map.get(sum) + 1);
            } else {
                map.put(sum, 1);
            }
        }
        return count;
    }


法2:
public int subarraySum(int[] nums, int k) {
    int left = 0;
    int right = 0;
    int sum = 0;
    int count = 0;
    for (left = 0; left < nums.length; left++) {
        sum = 0;
        for (right = left; right < nums.length; right++) {
            sum += nums[right];
            if (sum == k) {
                count++;
            }
        }
    }
    return count;
}

法3:
 HashMap<Integer, List<Integer>> map = new HashMap<>();

    public int subarraySum(int[] nums, int k) {
        int sum = 0;
        int ret = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (map.containsKey(sum)) {
                List<Integer> temp = map.get(sum);
                temp.add(i);
                map.put(sum, temp);
            } else {
                List<Integer> temp = new ArrayList<Integer>();
                temp.add(i);
                map.put(sum, temp);
            }
        }
        sum = 0;
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(sum + k)) {
                List<Integer> temp = map.get(sum + k);
                for (int num : temp) {
                    if (num >= i) {
                        ret++;
                    }
                }
            }
            sum += nums[i];
        }
        return ret;
    }
```



#### [@221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

@ 状态转移的方程也比较好理解. 以i,j作为右下角的正方形的最大边长,是由`  [i-1][j-1] 和[i-1][j]和[i][j-1]`为右下角的三个正方形边长共同决定的.

如图:`dp[2][2] 受限于dp[1][2]=1`

 1   1   0

 1   1    1

 1   1     1 



```java
public int maximalSquare(char[][] matrix) {
    int rowBound = matrix.length;
    int colBound = rowBound > 0 ? matrix[0].length : 0;
    int[][] dp = new int[rowBound + 1][colBound + 1];
    int maxSquare = 0;
    for (int i = 1; i <= rowBound; i++) {
        for (int j = 1; j <= colBound; j++) {
            if (matrix[i - 1][j - 1] == '1') {
                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i - 1][j - 1]), dp[i][j - 1]) + 1;
                maxSquare = Math.max(dp[i][j], maxSquare);
            }

        }
    }
    return maxSquare * maxSquare;
}

//空间优化的写法
 public int maximalSquare(char[][] matrix) {
        int rowBound = matrix.length;
        int colBound = rowBound > 0 ? matrix[0].length : 0;
        int[] dp = new int[colBound + 1];
        int maxSquare = 0;
        int temp = 0, pre = 0;
        for (int i = 1; i <= rowBound; i++) {
            for (int j = 1; j <= colBound; j++) {
                temp = dp[j];
                if (matrix[i - 1][j - 1] == '1') {
                    dp[j] = Math.min(Math.min(dp[j], dp[j - 1]), pre) + 1;
                    maxSquare = Math.max(dp[j], maxSquare);
                } else {
                    // dp[j]在用过多次后,后续不为零,要重新清理
                    dp[j] = 0;
                }
                空间优化的写法,temp,pre的使用
                pre = temp;
            }
        }
        return maxSquare * maxSquare;
    }
```

#### [@34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

@自己做出来了 但是要更加熟练.

注意的几个点

1.while(left<=right)

2.Lower的时候:return left; Upper的时候: return right;

3.应对没找到返回-1的情况 准备标志位founded.

```java
改进:find不到就返回-1
    getLower 和 getUpper的学习

public int[] searchRange(int[] nums, int target) {
        int left = getLower(nums, target);
        int right = getUpper(nums, target);
        return new int[]{left, right};
    }

    private int getUpper(int[] nums, int target) {
        int low = 0, high = nums.length - 1;
        boolean found = false;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] < target) {
                low = mid + 1;
            } else if (nums[mid] == target) {
                low = mid + 1;
                found = true;
            } else if (nums[mid] > target) {
                high = mid - 1;
            }
        }
        return found ? high : -1;
    }

    private int getLower(int[] nums, int target) {
        int low = 0, high = nums.length - 1;
        boolean found = false;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] > target) {
                high = mid - 1;
            } else if (nums[mid] == target) {
                high = mid - 1;
                found = true;
            } else if (nums[mid] < target) {
                low = mid + 1;
            }
        }
        return found ? low : -1;
    }
```

#### [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

```java
改进:还有一个方法二.

public boolean searchMatrix(int[][] matrix, int target) {
    int rowBound = matrix.length;
    if (rowBound == 0 || matrix[0].length == 0) {
        return false;
    }
    int colBound = matrix[0].length;
    for (int i = rowBound - 1; i >= 0; i--) {
        if (matrix[i][0] == target) {
            return true;
        } else if (matrix[i][0] < target && matrix[i][colBound - 1] >= target) {
            int foundIndex = binarySearch(matrix[i], target);
            if (foundIndex != -1) {
                return true;
            }
        }
    }
    return false;
}

private int binarySearch(int[] nums, int target) {
    int low = 0, high = nums.length - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}


方法二
public boolean searchMatrix(int[][] matrix, int target) {
        // start our "pointer" in the bottom-left
        int row = matrix.length-1;
        int col = 0;

        while (row >= 0 && col < matrix[0].length) {
            if (matrix[row][col] > target) {
                row--;
            } else if (matrix[row][col] < target) {
                col++;
            } else { // found it
                return true;
            }
        }

        return false;
    }
```







#### [@79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

@再做一遍  不熟练.典型回溯,但是因为字符边界问题老是出错

本题只要求返回true,false;但是没法用动规来做

```java
改进:回溯,没啥好说的,继续熟练
boolean[][] visited;
    boolean found;
    int rowBound;
    int colBound;
    int[][] loc = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    public boolean exist(char[][] board, String word) {
        if (board == null || board.length == 0 || board[0].length == 0) {
            return false;
        }
        rowBound = board.length;
        colBound = board[0].length;
        visited = new boolean[rowBound][colBound];

        for (int i = 0; i < rowBound; i++) {
            for (int j = 0; j < colBound; j++) {
                backtracing(board, i, j, 0, word);
            }
        }
        return found;
    }

    private void backtracing(char[][] board, int row, int col, int path, String word) {
        if (found) {
            return;
        }
        if (row < 0 || col < 0 || row >= rowBound || col >= colBound) {
            return;
        }
        if (board[row][col] != word.charAt(path) || visited[row][col]) {
            return;
        }
        if (board[row][col] == word.charAt(path) && path == word.length() - 1) {
            found = true;
            return;
        }
        visited[row][col] = true;
        for (int i = 0; i < loc.length; i++) {
            int rowTemp = row + loc[i][0];
            int colTemp = col + loc[i][1];
            backtracing(board, rowTemp, colTemp, path + 1, word);
        }
        visited[row][col] = false;
    }
```



#### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```java
改进:方法很巧妙,有四点值得学
//1.删除节点的题,可以添加一个头结点来用
//2.pre前进N+1步
//3.删除倒数第n个节点,但second到了倒数第n+1就停下,为了使用 second.next = second.next.next;
//4.链表类题目的画图方式  [pHead] [head]  []  []  []  null

public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode pHead = new ListNode(1);
    pHead.next = head;
    ListNode pre = pHead;
    ListNode second = pHead;
    for (int i = 1; i <= n + 1; i++) {
        pre = pre.next;//其实应该判空
    }
    while (pre != null) {
        second = second.next;
        pre = pre.next;
    }
    second.next = second.next.next;
    return pHead.next;
}
```



#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

@跟最长上升子序列一样,dp[i]要初始化成一个值,而非一开始的0.

最长上升子序列,dp[i]初始为1

这道题,如果dp[coins[j]]之前把赋值成1的话,则没有关系.如果之前没有赋值成1,则i的循环开始时,赋值成Integer.MAX_VALUE;代表这个amout无法被找零.



```java
改进:
//动态规划三部演化:  递归(自顶向下)->带备忘录的递归(自顶向下,也就是把递归树剪枝,已经算过的不再重复计算)->动态规划(自底向上)
//背包问题dp[i][j] i是选到第i个物品,j是当前的和,里面的值是
//斐波那契,跳台阶,零钱兑换  dp[i] i是和,是台阶总高,是当前拼凑的总钱数;里面的值是
//里面的值取决于题目,有的是方案可行,有的是方案次数,有的是最优子结构(即最少的拼凑次数,
//最少的跳台阶数,最少的背包物品数)

//我定好base case,同时知道dp[n]是由下面的dp[n-1]等怎么得来的,就可以写出代码


//该代码是下面的优化版本
public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        dp[0] = 0;
        int maxValue = Integer.MAX_VALUE;
        for (int i = 1; i <= amount; i++) {
            dp[i] = maxValue;
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i && dp[i - coins[j]] != maxValue) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] == maxValue ? -1 : dp[amount];
    }

//这个版本可以优化成上面
public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
    	//其实上面的for循环可以省略掉.
        for (int i = 0; i < coins.length; i++) {
            if (coins[i] <= amount) {
                dp[coins[i]] = 1;
            }
        }
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            dp[i] = Integer.MAX_VALUE;
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i && dp[i - coins[j]] >= 0 && dp[i - coins[j]] != Integer.MAX_VALUE) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }







public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    //初始化为amount+1是因为一个amount最差也可以由amount个1分硬币构成,所以amount+1是一个不可能的数
    //之所以用amount+1 而不用 -1是因为dp[i] = Math.min(dp[i], dp[i - coin] + 1);是要求最小值
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (coin <= i) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    return dp[amount] == amount + 1 ? -1 : dp[amount];
}
```

#### [@@@152. 乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray/)



```java
改进:1.状态转移方程
     dp[i][0] = Math.max(imax * nums[i - 1], nums[i - 1]);
     dp[i][1] = Math.min(imin * nums[i - 1], nums[i - 1]);
	2.因为负负得正,所以维护最小值也是有必要的
	3.因为只与前一个dp数据有关,dp数组可以被优化空间
        
 public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int max = nums[0];
        int[][] dp = new int[nums.length][2];
        for (int i = 0; i < nums.length; i++) {
            if (i == 0) {
                dp[i][0] = nums[0];
                dp[i][1] = nums[0];
                continue;
            }
            int num1 = dp[i - 1][0] * nums[i];
            int num2 = dp[i - 1][1] * nums[i];
            dp[i][0] = Math.max(nums[i], Math.max(num1, num2));
            dp[i][1] = Math.min(Math.min(num1, num2), nums[i]);
            max = Math.max(dp[i][0], max);
        }
        return max;
    }

改进:优化空间
    public int maxProduct(int[] nums) {
        int max = Integer.MIN_VALUE, imax = 1, imin = 1;
        for (int i = 0; i < nums.length; i++) {
            int temp = nums[i];
            if (temp < 0) {
                int swap = imax;
                imax = imin;
                imin = swap;
            }
            imax = Math.max(imax * nums[i], nums[i]);
            imin = Math.min(imin * nums[i], nums[i]);
            max = Math.max(imax, max);
        }
        return max;
    }
```



#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```java
改进:1.巧法:如果l1或者l2为空,则它的值可以看做0,这样就不用后续再对剩下一条非空链做单独处理
    2.见备注的一些细节

public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    int num1 = 0;
    int num2 = 0;
    int sum = 0;
    int addOnePre = 0;
    int addOneNow = 0;
    ListNode pHead = new ListNode(1);
    ListNode pre = pHead;
    while (l1 != null || l2 != null) {
        num1 = l1 == null ? 0 : l1.val;
        num2 = l2 == null ? 0 : l2.val;
        sum = num1 + num2;
        if (addOneNow == 1) {
            //先sum++再判断是否超过10
            sum++;
        }
        if (sum >= 10) {
            sum = sum % 10;
            addOnePre = 1;
        } else {
            addOnePre = 0;
        }

        ListNode node = new ListNode(sum);
        pre.next = node;
        pre = pre.next;
        addOneNow = addOnePre;

        l1 = l1 == null ? null : l1.next;
        l2 = l2 == null ? null : l2.next;
    }
    //如果l1和l2都空了,但还有一个进位,也要把这个进位考虑到
    if (addOneNow == 1) {
        pre.next = new ListNode(1);
    }
    return pHead.next;
}
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```java
改进:利用搜索树的性质

boolean ret = true;

public boolean isValidBST(TreeNode root) {
    ArrayList<Integer> list = new ArrayList<>();
    inOrder(root, list);
    return ret;
}

private void inOrder(TreeNode root, ArrayList<Integer> list) {
    if (ret == false) {
        return;
    }
    if (root == null) {
        return;
    }
    inOrder(root.left, list);
    if (list.size() >= 1 && root.val <= list.get(list.size() - 1)) {
        ret = false;
        return;
    } else {
        list.add(root.val);
    }
    inOrder(root.right, list);
}
```

#### [@@@@31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

@思路记住了.主要是边界条件要小心.

思路讲解:https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode/

```java
改进: 从后往前,找到第一个不满足降序的数字 nums[targetIndex]
    再从后往前,找到第一个降序的子数组中比nums[targetIndex]大的nums[i]
	交换nums[targetIndex] 和 nums[i]
    再把targetIndex后面的数变成升序.
    
    上面的思路有点像 一个数字,比如129,降序数组就是9,把2变成3,129就成了139,然后把降序数组9改成升序数组0
    最终变成了130.
    
    
 public void nextPermutation(int[] nums) {
        int changeIndex = -1;
        int swapIndex = 0;
        if (nums == null || nums.length == 0) {
            return;
        }
        //9 8 3 7 6 1 找到从后往前的第一个非升序, 数字3处的索引2
        for (int i = nums.length - 1; i > 0; ) {
            if (nums[i] <= nums[i - 1]) {
                i--;
            } else if (nums[i] > nums[i - 1]) {
                changeIndex = i - 1;
                break;
            }
        }
        //如果已经是最大值,就把nums翻转成最小值
        if (changeIndex == -1) {
            reverse(nums, 0, nums.length - 1);
            return;
        }
        //把3和6交换位置
        for (int i = nums.length - 1; i > 0; i--) {
            if (nums[i] > nums[changeIndex]) {
                swapIndex = i;
                break;
            }
        }
        int temp = nums[swapIndex];
        nums[swapIndex] = nums[changeIndex];
        nums[changeIndex] = temp;
        reverse(nums, changeIndex + 1, nums.length - 1);
        return;
    }

    private void reverse(int[] nums, int left, int right) {
        while (left < right) {
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++;
            right--;
        }
    }
```

#### 背包问题的理解

#### @@@@@01背包

背包容量是m,一共有n件物品

```
dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]);
```



#### 完全背包

```java
因为每种物品数量无限,所以到了选择第i件物品的时候,要么一件不放(dp[i][j] = dp[i-1][j])要么放1,2,3..k件
dp[i][j] = dp[i][j-weight[i]]+value[i];

所以代码为
for(int i = 1;i<n;i++){
	for(int j = 1;j<=W;j++){
		if(j<weight[i]){
			dp[i][j] = dp[i-1][j];
		}else{
			//要么一个也不放,要么在i物品上能放多少就放多少
			dp[i][j] = Math.max(dp[i-1][j],dp[i][j-weight[i]]+value[i]);
            //其实和多重背包是一样的?k是从0到无限大??  下面是自己的猜测,能不能用做题验证
  			dp[i][j] = Math.max(dp[i-1][j],dp[i][j-weight[i]*k]+value[i]*k);
            dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weight[i]*k]+value[i]*k);
		}
	}
}
```



#### 多重背包

```java
每种物品都有数量限制,限制的数值是k,,要么一件不放(dp[i][j] = dp[i-1][j])要么放1,2,3..k件
dp[i][j] = dp[i][j-weight[i]]+value[i];

for(int i = 1;i<n;i++){
	for(int j = 1;j<=W;j++){
		if(j<weight[i]){
			dp[i][j] = dp[i-1][j];
		}else{
			int count = min(num[i],j/weight[i]);
			//要么一个也不放
			dp[i][j] = dp[i-1][j];
			for(int k = 0;k<count;k++){
			//要么1,2...k个都试一下
				dp[i][j] = Math.max(dp[i][j],dp[i-1][j-weight[i]*k]+value[i]*k);
			}
		}
	}
}
```





#### [@@33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

```java
改进:做题的一般步骤,理解题意,确认题型,梳理给出的条件
    写代码:  先画出一个比较通用的情况,然后根据情况写代码; 然后再进行边界的处理(有的边界想不到会有致命bug,有的只是逻辑不健全,后者可以在代码通过一般情况后再考虑);然后空间,时间优化,逻辑结构优化
        
        
    本题思路,对半查找,有一半递增,有一半增减.检测target和递增的部分首尾的关系,进而决定low或者high接下来的变化

public int search(int[] nums, int target) {
    int len = nums.length;
    int low = 0, high = len - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[low] <= nums[mid]) {
            if (nums[low] > target || nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        } else {
            if (nums[mid] > target || nums[high] < target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
    }
    return -1;
}
```









#### [@@3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

@子串类的题目,要注意可以用动规来做



```java
改进:思路滑动窗口
public int lengthOfLongestSubstring(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    int len = s.length();
    int left = 0;
    int right = 0;
    int max = 0;
    HashMap<Character, Integer> charIndexMap = new HashMap<>();
    for (; right < len; right++) {
        char ch = s.charAt(right);
        if (charIndexMap.containsKey(ch)) {
            int charIndex = charIndexMap.get(ch);
            if (charIndex >= left) {
                for (; left <= charIndex; left++) {
                    charIndexMap.remove(s.charAt(left));
                }
            }
        }
        charIndexMap.put(ch, right);
        max = Math.max(max, right - left + 1);
    }
    return max;
}
```











#### [@56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

```java
改进:思路 1.按照每个区间的左起点排序,
		2.根据i的right和 i+1的left能否相交决定是否合并区间(right = Math.max(right, intervals[i][1]);
        3.right = Math.max(right, intervals[i][1]);而非right = intervals[i][1],比如(1,9) (2,4)
        还是原来的right大
        4.创建ArrayList<int[]> ret; 转换的时候 ret.toArray(new int[0][]);

public int[][] merge(int[][] intervals) {
        if (intervals == null || intervals.length == 0) {
            return new int[][]{};
        }
        Comparator<int[]> c = new Comparator<int[]>() {
            public int compare(int[] i1, int[] i2) {
                return i1[0] - i2[0];
            }
        };
        int len = intervals.length;
        ArrayList<int[]> ret = new ArrayList<>();
        Arrays.sort(intervals, c);
        for (int i = 0; i < len; ) {
            int start = intervals[i][0];
            int end = intervals[i][1];
            i = i + 1;
            if (i < len && end >= intervals[i][0]) {
                while (i < len && end >= intervals[i][0]) {
                    end = Math.max(end, intervals[i][1]);
                    i++;
                }
            }
            ret.add(new int[]{start, end});
        }
        int[][] retArray = new int[ret.size()][2];
        for (int i = 0; i < ret.size(); i++) {
            retArray[i] = ret.get(i);
        }
        return retArray;
    }
```



#### [@@@128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

@hashMap

@@@注意只有当! map.containsKey(num-1)时,寻找最长连续序列的while循环才开始运行.



```java
思路1:哈希表
    private HashMap<Integer, Integer> map = new HashMap<>();

    public int longestConsecutive(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        for (int temp : nums) {
            map.put(temp, 1);
        }
        int maxLen = 0;
        int curLen = 0;
        for (int temp : nums) {
            if (!map.containsKey(temp - 1)) {
                curLen = 1;
                while (map.containsKey(temp + 1)) {
                    temp++;
                    curLen++;
                }
                maxLen = Math.max(maxLen, curLen);
            }
        }
        return maxLen;
    }



思路2:排序,然后从左到右遍历
    
    
public int longestConsecutive(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return 1;
        }
        Arrays.sort(nums);
        //两种排序再熟悉一下
        int right = 1;
        int maxCount = 1;
        int cnt = 1;
        while (right < nums.length) {
            if (nums[right] == nums[right - 1] + 1) {
                cnt++;
                maxCount = Math.max(maxCount, cnt);
                right++;
                while (right < nums.length && nums[right] == nums[right - 1]) {
                    right++;
                }
            } else {
                right++;
                while (right < nums.length && nums[right] == nums[right - 1]) {
                    right++;
                }
                cnt = 1;
            }
        }
        return maxCount;
    }
    
    
public int longestConsecutive(int[] nums) {
    if (nums.length == 0) {
        return 0;
    }
    Arrays.sort(nums);
    int max = 1;
    int cnt = 1;
    for (int i = 0; i < nums.length - 1; i++) {
        while (i < nums.length - 1 && nums[i] == nums[i + 1]) {
            i++;
        }
        if (i < nums.length - 1 && nums[i] + 1 == nums[i + 1]) {
            cnt++;
        } else if (i < nums.length - 1 && nums[i] + 1 != nums[i + 1]) {
            cnt = 1;
        }
        max = Math.max(cnt, max);
    }
    return max;
}
```



#### [@23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

归并排序.再学习.



```java
思路1:分而治之法

 public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }
        return merge(lists, 0, lists.length - 1);
    }

    private ListNode merge(ListNode[] lists, int left, int right) {
        if (left == right) {
            return lists[left];
        }
        int mid = left + (right - left) / 2;
        ListNode l1 = merge(lists, left, mid);
        ListNode l2 = merge(lists, mid + 1, right);
        return mergeTwoList(l1, l2);
    }

    private ListNode mergeTwoList(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(0);
        ListNode pre = head;
        while (l1 != null || l2 != null) {
            if (l1 != null && l2 != null) {
                if (l1.val > l2.val) {
                    pre.next = l2;
                    pre = pre.next;
                    l2 = l2.next;
                } else {
                    pre.next = l1;
                    pre = pre.next;
                    l1 = l1.next;
                }
            } else if (l1 != null) {
                pre.next = l1;
                pre = pre.next;
                l1 = l1.next;
            } else if (l2 != null) {
                pre.next = l2;
                pre = pre.next;
                l2 = l2.next;
            }
        }
        return head.next;
    }




思路2:优先队列

public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) {
        return null;
    }
    ListNode head = new ListNode(1);
    ListNode pre = head;

    PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>(1, (a, b) -> (a.val - b.val));
    for (int i = 0; i < lists.length; i++) {
        if (lists[i] != null) {
            queue.add(lists[i]);
        }
    }
    while (!queue.isEmpty()) {
        ListNode temp = queue.poll();
        pre.next = temp;
        pre = pre.next;
        if (temp.next != null) {
            queue.add(temp.next);
        }
    }
    return head.next;
}
```





#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```java
改进思路: 双递归:一层递归求该树的每个节点为root的路径最大值,一层递归求特定root根的左右子树路径的sum
    	注意:如果root.val或者 左右子树+root.val小于零,则return 0; 丢弃该子树

思路1是思路2的改进,把双递归写成了单递归
	int max = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        setMaxAndReturnSingleMax(root);
        return max;
    }

    private int setMaxAndReturnSingleMax(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftLen = setMaxAndReturnSingleMax(root.left);
        int rightLen = setMaxAndReturnSingleMax(root.right);
        // 与max比较,设置以该root为根的最长左单边+右单边
        max = Math.max(max, leftLen + rightLen + root.val);
        //获取以root为根的左右单边的最长,返回回去供上一级root使用
        int singleMaxPath = Math.max(leftLen, rightLen) + root.val;
        return Math.max(singleMaxPath, 0);
    }
            
            
思路2:
 int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        setMax(root);
        return max;
    }
    //获取以root为根的左右两边最长之和,并与max比较
    private void setMax(TreeNode root) {
        if (root == null) {
            return;
        }
        setMax(root.left);
        setMax(root.right);
        int leftLen = gainSingleMaxPath(root.left);
        int rightLen = gainSingleMaxPath(root.right);
        max = Math.max(max, leftLen + rightLen + root.val);
    }
    //获取以root为根的单边(要么左子树,要么右子树)的最长
    private int gainSingleMaxPath(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftLen = gainSingleMaxPath(root.left);
        int rightLen = gainSingleMaxPath(root.right);
        int singleMaxPath = Math.max(leftLen, rightLen) + root.val;
        return Math.max(singleMaxPath, 0);
    }



```

#### [@@@239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

```java
思路1:双端队列法:

public int[] maxSlidingWindow(int[] nums, int k) {
    ArrayList<Integer> ret = new ArrayList<Integer>();
    Deque<Integer> deque = new ArrayDeque<Integer>();
    int max = 0;
    for (int i = 0; i < nums.length; i++) {
        if (!deque.isEmpty() && deque.getFirst() <= i - k) {
            deque.removeFirst();
        }

        while (!deque.isEmpty() && nums[deque.getLast()] < nums[i]) {
            deque.removeLast();
        }
        deque.addLast(i);
        if (i >= k - 1) {
            ret.add(nums[deque.getFirst()]);
        }
    }
    int[] retArray = new int[ret.size()];
    int i = 0;
    for (int temp : ret) {
        retArray[i++] = temp;
    }
    return retArray;
}

思路2:大顶堆法
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0 || nums.length < k) {
            return new int[]{};
        }
        Comparator<Integer> c = new Comparator<Integer>() {
            public int compare(Integer i1, Integer i2) {
                return nums[i2] - nums[i1];
            }
        };
        ArrayList<Integer> ret = new ArrayList<>();
        PriorityQueue<Integer> heap = new PriorityQueue<Integer>(10, c);
        int right = 0;
        int len = nums.length;
        for (right = 0; right <= len; right++) {
            if (right < k) {
                heap.add(right);
                continue;
            }
            ret.add(nums[heap.peek()]);
            heap.remove(right - k);
            if (right < len) {
                heap.add(right);
            }
        }
        int[] retArray = new int[ret.size()];
        for (int i = 0; i < ret.size(); i++) {
            retArray[i] = ret.get(i);
        }
        return retArray;
    }



```



#### [@@@42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)



```java
思路1: 每一个height[i]只有左边和右边分别有比它高的墙才能存住水,
	   所以利用动规,存住i处 左边最高left[i]和右边最高right[i],求min =Math.min(left[i], right[i]);
       

public int trap(int[] height) {
    if (height == null || height.length == 0) {
        return 0;
    }
    int len = height.length;
    int[] left = new int[len];
    int[] right = new int[len];
    int maxHeight = 0;
    int sum = 0;
    for (int i = 1; i < len; i++) {
        if (height[i - 1] > maxHeight) {
            maxHeight = height[i - 1];
        }
        left[i - 1] = maxHeight;
    }
    maxHeight = 0;
    for (int i = len - 2; i >= 0; i--) {
        if (height[i + 1] > maxHeight) {
            maxHeight = height[i + 1];
        }
        right[i + 1] = maxHeight;
    }
    for (int i = 1; i < len - 1; i++) {
        int min = Math.min(left[i], right[i]);
        if (min > height[i]) {
            sum += min - height[i];
        }
    }
    return sum;
}
```



#### [@@@84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)



@@@最小栈法

@width的边界的界定

@哨兵

@持续的pop()最小顶点

```java
@@@最小栈法
public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<Integer>();
        int maxArea = 0;

        int[] newHeights = new int[heights.length + 2];
        for (int i = 1; i < newHeights.length - 1; i++) {
            newHeights[i] = heights[i - 1];
        }
        for (int i = 0; i < newHeights.length; i++) {
            while (!stack.isEmpty() && newHeights[i] < newHeights[stack.peek()]) {
                //为什么pop出来,为什么curWidth是i - (stack.peek() + 1)而不是 i-stack.peek()
                // 举例  有数组2,1,2
                //stack中的1成为rightIndex的时候,stack里面还有 0这一个index
                //以newHeight[1]为高的矩形的最大宽度的左边界  不是1
                // 而是i -(0+1),即 比newHeight[1]小的索引位+1 也就是0+1
                int rightIndex = stack.pop();
                int curHeight = newHeights[rightIndex];

                int curWidth = i - (stack.peek() + 1);
                int area = curWidth * curHeight;
                maxArea = Math.max(maxArea, area);
            }
            stack.push(i);
        }
        return maxArea;
    }





分而治之法:
先找到start 到end 范围内的minHeight;
Area的最大值分三种情况:
1.minIndex左边的部分求出来的最大Area
2.minIndex右边的部分求出来的最大Area
3.minHeight*(end-start+1)

public int calculateArea(int[] heights, int start, int end) {
    if (start > end) {
        return 0;
    }
    //注意这里是以minIndex为分界线.
    int minIndex = start;
    for (int i = start; i <= end; i++) {
        if (heights[minIndex] > heights[i]) {
            minIndex = i;
        }
    }
    int leftMaxArea = calculateArea(heights, start, minIndex - 1);
    int rightMaxArea = calculateArea(heights, minIndex + 1, end);
    int minIndexArea = heights[minIndex] * (end - start + 1);
    return Math.max(minIndexArea, Math.max(leftMaxArea, rightMaxArea));
}

public int largestRectangleArea(int[] heights) {
    if (heights == null || heights.length == 0) {
        return 0;
    }
    return calculateArea(heights, 0, heights.length - 1);
}
```

#### [@@@76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

@@map初始化的时候,把每种ch都记录一遍出现最大次数    存最大次数的操作要记住

滑动窗口遇到就--.

```java
思路:滑动窗口类的题目,都是left指针+right指针.
    然后先right往右走找到可行解,left往左走,把解优化到最小值.
    重点就在于窗口内的匹配.本题目由于字符串的匹配是无序的,所以用map<Character,Integer> 和 一个mathCount
    

public String minWindow(String s, String t) {
    //我先不判空,居然通过了
    int matchCount = t.length();
    HashMap<Character, Integer> map = new HashMap<>();
    for (int i = 0; i < t.length(); i++) {
        char c = t.charAt(i);
        if (map.containsKey(c)) {
            map.put(c, map.get(c) + 1);
        } else {
            map.put(c, 1);
        }
    }
    int left = 0;
    int right = 0;
    String minLen = "";
    while (right < s.length()) {
        char temp = s.charAt(right);
        if (map.containsKey(temp)) {
            if (map.get(temp) > 0) {
                matchCount--;
            }
            map.put(temp, map.get(temp) - 1);
        }
        while (matchCount == 0) {
            char temp2 = s.charAt(left);
            if (map.containsKey(temp2)) {
                map.put(temp2, map.get(temp2) + 1);

                if (map.get(temp2) > 0) {
                    if (minLen.length() == 0) {
                        minLen = s.substring(left, right + 1);
                    } else if (minLen.length() > (right - left + 1)) {
                        minLen = s.substring(left, right + 1);
                    }
                    matchCount++;
                }
            }
            left++;
        }
        right++;

    }
    return minLen;
}
```





#### [@438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

@一开始忘了cnt + map<char,int> 的方法,再做一遍熟练起来

```java
思路:滑动窗口,维护left和right.
    left和right逐渐往右移动,并寻找匹配的字符串.
    注意,此题需要1. s判空,2. 判p的长度要小于s. 有的题会考这种细节,有的不会考
    
     public List<Integer> findAnagrams(String s, String p) {
        HashMap<Character, Integer> map = new HashMap<>();
        List<Integer> ret = new ArrayList<>();
        int cnt = p.length();
        int left = 0;
        int right = 0;
    	//初始化map
        for (int i = 0; i < p.length(); i++) {
            char ch = p.charAt(i);
            if (map.containsKey(ch)) {
                map.put(ch, map.get(ch) + 1);
            } else {
                map.put(ch, 1);
            }
        }
    	//right右移
        for (right = 0; right < s.length(); right++) {
            char ch = s.charAt(right);
            if (map.containsKey(ch)) {
                if (map.get(ch) > 0) {
                    cnt--;
                }
                map.put(ch, map.get(ch) - 1);
            } else {
                //s中出现了map中没有的字符,则left的起点至少要设在这个字符之后
                //其实没必要,因为上面这种情况发生的话,cnt不会为0.
                int i = left;
                left = right + 1;
                for (; i < left; i++) {
                    ch = s.charAt(i);
                    if (map.containsKey(ch)) {
                        map.put(ch, map.get(ch) + 1);
                        if (map.get(ch) > 0) {
                            cnt++;
                        }
                    }
                }
            }
            //匹配了就ret.add
            if (cnt == 0) {
                ret.add(left);
            }
            //滑动窗口过大,就left++,并修改cnt和map
            if (right - left + 1 >= p.length()) {
                ch = s.charAt(left);
                if (map.containsKey(ch)) {
                    map.put(ch, map.get(ch) + 1);
                    if (map.get(ch) > 0) {
                        cnt++;
                    }
                }
                left++;
            }
        }
        return ret;
    }
    
    
之前的提交:
    
public List<Integer> findAnagrams(String s, String p) {
    ArrayList<Integer> list = new ArrayList<>();
    HashMap<Character, Integer> map = new HashMap<>();
    int left = 0;
    int right = p.length() - 1;
    int matchCount = p.length();
    if (s == null || s.length() == 0 || p.length() > s.length()) {
        return list;
    }

    for (int i = 0; i < p.length(); i++) {
        char ch = p.charAt(i);
        if (map.containsKey(ch)) {
            map.put(ch, map.get(ch) + 1);
        } else {
            map.put(ch, 1);
        }
    }
    for (int i = 0; i < p.length(); i++) {
        char ch = s.charAt(i);
        if (map.containsKey(ch)) {
            if (map.get(ch) > 0) {
                matchCount--;
            }
            map.put(ch, map.get(ch) - 1);
        }
    }
    while (right < s.length()) {
        if (matchCount == 0) {
            list.add(left);
        }
        //左右都移动
        char ch = s.charAt(left);
        if (map.containsKey(ch)) {
            map.put(ch, map.get(ch) + 1);
            if (map.get(ch) > 0) {
                matchCount++;
            }
        }
        left++;
        right++;
        if (right < s.length()) {
            ch = s.charAt(right);
            if (map.containsKey(ch)) {
                if (map.get(ch) > 0) {
                    matchCount--;
                }
                map.put(ch, map.get(ch) - 1);
            }
        }
    }
    return list;
}
```



#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

```java
思路3个:
1.dfs
2.bfs
3.查并集

    
 //   dfs:

 private boolean[][] marked;
    private int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    char[][] grid;
    int row = 0;
    int col = 0;
    int count = 0;

    public int numIslands(char[][] grid2) {
        grid = grid2;
        if (grid == null || grid.length == 0) {
            return 0;
        }
        row = grid.length;
        col = grid[0].length;
        marked = new boolean[row][col];

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (isHealthy(i, j)) {
                    dfs(i, j);
                    count++;
                }
            }
        }
        return count;
    }

    private boolean isHealthy(int row, int col) {
        if (row < 0 || col < 0 || row > grid.length - 1 || col > grid[0].length - 1 || marked[row][col] || grid[row][col] == '0') {
            return false;
        }
        return true;
    }

    private void dfs(int row, int col) {
        if (isHealthy(row, col)) {
            marked[row][col] = true;
            for (int i = 0; i < directions.length; i++) {
                int newRow = row + directions[i][0];
                int newCol = col + directions[i][1];
                dfs(newRow, newCol);
            }
        }
    }




//bfs 但是会超时,
   private boolean[][] marked;
    private int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    char[][] grid;
    int row = 0;
    int col = 0;
    int count = 0;

    public int numIslands(char[][] grid2) {
        grid = grid2;
        if (grid == null || grid.length == 0) {
            return 0;
        }
        row = grid.length;
        col = grid[0].length;
        marked = new boolean[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (isHealthy(i, j)) {
                    Queue<Location> queue = new LinkedList<>();
                    Location loc = new Location(i, j);
                    queue.add(loc);
                    count++;
                    while (!queue.isEmpty()) {
                        Location temp = queue.poll();
                        int X = temp.x;
                        int Y = temp.y;
                        marked[X][Y] = true;
                        for (int k = 0; k < directions.length; k++) {
                            int newX = X + directions[k][0];
                            int newY = Y + directions[k][1];
                            if (isHealthy(newX, newY)) {
                                queue.add(new Location(newX, newY));
                            }
                        }
                    }
                }
            }
        }
        return count;
    }

    private boolean isHealthy(int row, int col) {
        if (row < 0 || col < 0 || row > grid.length - 1 || col > grid[0].length - 1 || marked[row][col] || grid[row][col] == '0') {
            return false;
        }
        return true;
    }

class Location {
    Integer x;
    Integer y;

    Location(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

//并查集.

//TODO


```





#### [@@@@139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

这个题是一个背包问题.index往后面遍历,决定某个index是否符合要求的原因是index-str.len  ~index是否能构成一个单词

for(;index<len;index++){

​      for(String temp1:wordDict){

@@@这个题 index往后遍历,

```java
本来想用回溯的办法,但是像这种只要求一个boolean结果或者一个int结果的
一般用回溯就会超时.
    
所以应该用动态规划代替.

dp[j] = dp[j-len]
比如  leetcode  与 leet code   dp[7] = dp[3]&&(s的code==wordDict里面的code)

 public boolean wordBreak(String s, List<String> wordDict) {
        if (s == null || s.length() == 0) {
            return false;
        }
        int len = s.length();
        boolean[] dp = new boolean[len + 1];
        dp[0] = true;
        for (int i = 1; i <= len; i++) {
            for (int j = 0; j < wordDict.size(); j++) {
                String str = wordDict.get(j);
                int strLen = str.length();
                if (i - strLen >= 0 && dp[i - strLen] == true) {
                    if (str.equals(s.substring(i - strLen, i))) {
                        dp[i] = true;
                        break;
                    }
                }
            }
        }
        return dp[len];
    }
    
    

public boolean wordBreak(String s, List<String> wordDict) {
    if (s == null || s.length() == 0) {
        return false;
    }
    HashSet<String> set = new HashSet<>(wordDict);
    int len = s.length();
    boolean[] dp = new boolean[len];
    String temp = "";
    int index = 0;

    //初始化dp[0]到第一个为true的dp.
    for (index = 0; index < len; index++) {
        temp = s.substring(0, index + 1);
        if (set.contains(temp)) {
            dp[index] = true;
            break;
        } else {
            dp[index] = false;
        }
    }
    //从index开始
    for (; index < len; index++) {
        //每一个wordDict里面的单词都试一下,能不能从index开始
        //往前匹配成功,并且dp[index-length]为true;
        for (String temp2 : wordDict) {
            int length = temp2.length();
            if (length - 1 <= index) {
                String temp3 = s.substring(index - length + 1, index + 1);
                if (temp2.equals(temp3)) {
                    if (index - length == -1) {
                        dp[index] = true;
                        break;
                    } else if (dp[index - length]) {
                        dp[index] = true;
                        break;
                    }
                }
            }
        }
    }
    return dp[index - 1];
}
```

 

#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

```java
思路:动态规划

public boolean canJump(int[] nums) {
    if (nums == null || nums.length == 0) {
        return false;
    }
    int len = nums.length;
    boolean[] dp = new boolean[len];
    dp[0] = true;
    for (int i = 1; i < len; i++) {
        for (int j = i - 1; j >= 0; j--) {
            if (dp[j] && nums[j] >= i - j) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[len - 1];
}
```





#### [@@662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

@@遍历每一个node,当level相同时,就计算breadth

如果level不相同,就更新cutlevel和left

```java
    public int widthOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<Node> queue = new LinkedList<Node>();
        queue.add(new Node(root, 0, 0));
        int left = 0;
        int right = 0;
        int curLevel = 0;
        int maxB = 0;
        int breadth = 0;
        while (!queue.isEmpty()) {
            Node node = queue.poll();
            addNodeChild(queue, node);
            int nodeLevel = node.level;
            int nodePosition = node.position;
            //当处在同一个level下实时计算breadth
            if (curLevel == nodeLevel) {
                right = nodePosition;
                breadth = right - left + 1;
                maxB = Math.max(maxB, breadth);
                //当level变更时,更换curLevel和left
            } else {
                left = nodePosition;
                curLevel = nodeLevel;
            }
        }
        return maxB;
    }


    private void addNodeChild(Queue<Node> queue, Node node) {
        TreeNode treeNode = node.treeNode;
        int level = node.level;
        int position = node.position;

        TreeNode left = treeNode.left;
        TreeNode right = treeNode.right;
        if (left != null) {
            queue.add(new Node(left, position * 2, level + 1));
        }
        if (right != null) {
            queue.add(new Node(right, position * 2 + 1, level + 1));
        }
    }


class Node {
    TreeNode treeNode = null;
    int position = 0;
    int level = 0;

    public Node(TreeNode treeNode, int position, int level) {
        this.treeNode = treeNode;
        this.position = position;
        this.level = level;
    }
}
```







#### [@15. 三数之和](https://leetcode-cn.com/problems/3sum/)

@这个题对于重复数据的处理很难,题目的难度是困难而非中等.

@@对于三数求和,可以用排序+左右指针,注意对于每个nums[i]只需要从其右边的数里面选nums[left]和 nums[right]

@回溯法对结果去重比较麻烦,本题专有法来做.

```java
改进:1.数组排序
    1. 以i为左起点,nums[i]大于0则可以剪枝,否则L++R--来寻找组合
    3.num[i]可能会有重复,要用最左边的num[i],不然比如 -1  -1 0 1 2,用最右边的nums[i]会漏掉 -1 -1 2 这种情况
    4.找到 num[i] nums[L] nums[R]的组合之后  L要一直++ R要一直--,直到nums[L]!=nums[L],为的是去除重复解
    比如 -2 -1 -1 0 3 3

public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ret = new ArrayList<>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {

            if (nums[i] > 0) {
                return ret;
            }
            int left = i + 1;
            int right = nums.length - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[left]);
                    list.add(nums[right]);
                    ret.add(list);
                    while (left + 1 < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    while (left < right - 1 && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    left++;
                    right--;
                } else if (sum > 0) {
                    right--;
                } else {
                    left++;
                }

            }
            while (i + 1 < nums.length && nums[i] == nums[i + 1]) {
                i++;
            }
        }
        return ret;
    }
@这个题很坑的是 回溯法不好去重,所以还是要用上面的排序法.
测试用例:
输入
[-1,0,1,2,-1,-4]
输出
[[-1,0,1],[-1,2,-1],[0,1,-1]]
预期结果
[[-1,-1,2],[-1,0,1]]
    
    
List<List<Integer>> ret = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> threeSum(int[] nums) {
        backtracing(nums, new ArrayList<>(), 0, 0);
        return ret;
    }

    private void backtracing(int[] nums, List<Integer> path, int sum, int index) {
        if (path.size() > 3) {
            return;
        }
        if (path.size() == 3 && sum == 0) {
            ret.add(new ArrayList<>(path));
            return;
        }
        for (int i = index; i < nums.length; i++) {
            path.add(nums[i]);
            backtracing(nums, path, sum + nums[i], i + 1);
            path.remove(path.size() - 1);
        }
    }
```





#### @归并排序(mergeSort)

结合128题.最长连续序列  里面的思路二,来验证排序

```java
public void mergeSort(int[] nums) {
        merge(nums, 0, nums.length - 1);
    }

    private void merge(int[] nums, int left, int right) {
        if (left >= right) {
            return;
        }
        //当时没想到临时数组
        int[] temp = new int[right - left + 1];
        int mid = left + (right - left) / 2;
        merge(nums, left, mid);
        merge(nums, mid + 1, right);

        //把nums的  left~mid   和  mid+1~right 合并到temp

        int i1 = left;
        int i2 = mid + 1;
        int i = 0;
        while (i1 <= mid && i2 <= right) {
            if (nums[i1] <= nums[i2]) {
                temp[i++] = nums[i1++];
            } else {
                temp[i++] = nums[i2++];
            }
        }
        while (i1 <= mid) {
            temp[i++] = nums[i1++];
        }
        while (i2 <= right) {
            temp[i++] = nums[i2++];
        }
        //把合并后的temp转移到nums
        i1 = left;
        for (i = 0; i < temp.length; ) {
            nums[i1++] = temp[i++];
        }
    }
```







#### @快速排序(quickSort)

结合128题.最长连续序列  里面的思路二,来验证排序

```java
 private void quickSort(int[] nums, int left, int right) {
        if (left >= right) {
            return;
        }
        int index = patition(nums, left, right);
        quickSort(nums, left, index - 1);
        quickSort(nums, index + 1, right);
    }

    private int patition(int nums[], int left, int right) {
        if (left >= right) {
            return left;
        }
        int temp = nums[left];
        while (left < right) {
            //用left<right 而不是left<=right是为了防止left越过right,swap的时候越界
            //left<right反而会让left和right最终重合
            while (left < right && nums[right] >= temp) {
                right--;
            }
            swap(nums, left, right);
            //nums[left]和 temp比较的时候用<=,而非< 为了让数组更快的总到尽头
            while (left < right && nums[left] <= temp) {
                left++;
            }
            swap(nums, left, right);
        }
        //返回left没有疑问,示例如下
        // 1,2,3,4,5    3,1,2,4,5
        nums[left] = temp;
        return left;
    }

    private void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
```



#### @@@堆排序

 @sort里面新建maxHeap,然后把最后一个元素移到末尾,adjust

@maxHeap里面从最后一个非子节点(len/2-1)开始调整,一直到0.

@调整函数里面,从index里面第一个子节点一直往下调整,最后temp放到应该在的位置上.

```java
public void sort(int[] nums) {
    int[] ints = maxHeap(nums);
    for (int endLen = nums.length; endLen > 0; endLen--) {
        //把根元素和末尾元素交换位置
        swap(nums, 0, endLen - 1);//endLen-1是index
        //以根元素 到 len = endLen-1的堆进行调整  (忽略了最后的末尾元素)
        adjustHeap(nums, 0, endLen - 1);//endLen-1是 len
    }
}

public int[] maxHeap(int[] nums) {
        //从第一个非叶子节点开始   len/2-1  到 根节点
        for (int i = nums.length / 2 - 1; i >= 0; i--) {
            adjustHeap(nums, i, nums.length);
        }
        return nums;
}

//在array里面,左子树为index*2+1,右子树为index*2+2
//在每一层position那里
private void adjustHeap(int[] nums, int index, int len) {
    int temp = nums[index];

    for (int childIndex = index * 2 + 1; childIndex < len; childIndex = childIndex * 2 + 1) {
        if (childIndex + 1 < len && nums[childIndex] < nums[childIndex + 1]) {
            childIndex++;
        }
        if (temp < nums[childIndex]) {
            nums[index] = nums[childIndex];
            index = childIndex;
        } else {
            break;
        }
    }
    nums[index] = temp;
}



private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```



#### @@但凡是有关left,right的函数,一般要判断left>right return



#### [面试题42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

```java
public int maxSubArray(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int len = nums.length;
    int[] dp = new int[len + 1];
    dp[1] = nums[0];

    int max = nums[0];
    for (int i = 2; i <= len; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i - 1], nums[i - 1]);
        max = Math.max(dp[i], max);
    }
    return max;
}
```



#### [面试题03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

```java
public int findRepeatNumber(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int len = nums.length;
    int index = 0;
    while (index < len) {
        int num = nums[index];
        if (num != index) {
            if (nums[num] == num) {
                return num;
            }
            int temp = nums[num];
            nums[num] = num;
            nums[index] = temp;
        } else {
            index++;
        }
    }
    return len;
}
```



#### [@@@@32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

@stack初始push一个-1

@  (   进栈

@ )  出栈,如果stack空了,代表)多了,再把)的indexpush进去,作为分界线.

@如果没空,代表匹配成功了  



```java
public int longestValidParentheses(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    int len = s.length();
    int maxLen = 0;
    Stack<Integer> stack = new Stack<Integer>();
    stack.push(-1);
    for (int i = 0; i < len; i++) {
        char ch = s.charAt(i);
        if (ch == '(') {
            stack.push(i);
        } else {
            stack.pop();
            if (stack.isEmpty()) {
                stack.push(i);
            } else {
                maxLen = Math.max(maxLen, i - stack.peek());
            }
        }
    }
    return maxLen;
}
```



#### [@935. 骑士拨号器](https://leetcode-cn.com/problems/knight-dialer/)



```java
public int knightDialer(int N) {
    if (N < 0) {
        return -1;
    }
    if (N == 1) {
        return 10;
    }
    boolean[][] cannotUse = new boolean[5][4];
    cannotUse[4][1] = true;
    cannotUse[4][3] = true;
    int[][][] dp = new int[5][4][N + 1];
    int[][] loc = new int[][]{{1, 2}, {1, -2}, {-1, 2}, {-1, -2}, {2, 1}, {2, -1}, {-2, 1}, {-2, -1}};
    for (int i = 1; i <= 4; i++) {
        for (int j = 1; j <= 3; j++) {
            for (int locIndex = 0; locIndex < loc.length; locIndex++) {
                int newI = i + loc[locIndex][0];
                int newJ = j + loc[locIndex][1];
                if (newI >= 1 && newI <= 4 && newJ >= 1 && newJ <= 3 && cannotUse[newI][newJ] == false) {
                    dp[i][j][1]++;
                }
            }
        }
    }
    int sum = 0;
    for (int k = 2; k <= N - 1; k++) {
        for (int i = 1; i <= 4; i++) {
            for (int j = 1; j <= 3; j++) {
                for (int locIndex = 0; locIndex < loc.length; locIndex++) {
                    int newI = i + loc[locIndex][0];
                    int newJ = j + loc[locIndex][1];
                    if (newI >= 1 && newI <= 4 && newJ >= 1 && newJ <= 3 && cannotUse[newI][newJ] == false) {

                        dp[i][j][k] += dp[newI][newJ][k - 1];
                        dp[i][j][k] = dp[i][j][k] % 1000000007;
                    }
                }
            }
        }
    }
    for (int i = 1; i <= 4; i++) {
        for (int j = 1; j <= 3; j++) {
            if (cannotUse[i][j] == false) {
                sum += dp[i][j][N - 1];
                sum = sum % (1000000007);
            }
        }
    }
    return sum;
}
```

#### [@@1353. 最多可以参加的会议数目](https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/)



@把events 根据开始顺序排序,today逐渐增长,从优先队列里,选剩余时间最少的会议来开.

```java
public int maxEvents(int[][] events) {
    int MAX_END = 100000;
    if (events == null || events.length == 0) {
        return 0;
    }
    Comparator<int[]> c = new Comparator<int[]>() {
        public int compare(int[] i1, int[] i2) {
            return i1[0] - i2[0];
        }
    };
    Arrays.sort(events, c);

    PriorityQueue<Integer> queue = new PriorityQueue<Integer>();

    int meetCount = 0;
    int i = 0;
    for (int today = 1; today <= MAX_END; today++) {
        while (i < events.length && events[i][0] == today) {
            queue.add(events[i][1]);
            i++;
        }
        if (!queue.isEmpty() && queue.peek() >= today) {
            meetCount++;
            queue.poll();
        }
        while (!queue.isEmpty() && queue.peek() <= today) {
            queue.poll();
        }
    }
    return meetCount;
}
```

















#### [@25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)



```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode node = head;
    ListNode retHead = new ListNode(-1);
    ListNode retEnd = retHead;
    while (true) {
        int count = 0;
        ListNode reverseHead = new ListNode(-1);
        ListNode lastNode = null;
        //注意记录lastNode,是count为0的时候
        while (node != null && count < k) {
            ListNode temp = node.next;
            node.next = reverseHead.next;
            reverseHead.next = node;
            //注意记录lastNode,是count为0的时候
            if (count == 0) {
                lastNode = node;
            }
            node = temp;
            count++;
        }

        if (count == k) {
            retEnd.next = reverseHead.next;
            retEnd = lastNode;
        } else {
            //如果最后的链表不足k个,就翻转回来原来的顺序
            ListNode remainList = reverse(reverseHead);
            retEnd.next = remainList;
            break;
        }
    }
    return retHead.next;
}

private ListNode reverse(ListNode head) {
    ListNode pHead = new ListNode(-1);
    ListNode node = head.next;
    while (node != null) {
        ListNode temp = node.next;
        node.next = pHead.next;
        pHead.next = node;
        node = temp;
    }
    return pHead.next;
}
```











#### [@@@721. 账户合并](https://leetcode-cn.com/problems/accounts-merge/)

同一个邮箱代表是同一个用户。

我们用输入账户的序号来代表账户。

例如：

[
0 [“John”,”johnsmith@mail.com”,”john_newyork@mail.com”],
1 [“John”,”johnsmith@mail.com”,”john00@mail.com”],
2 [“Mary”,”mary@mail.com”],
3 [“John”,”johnnybravo@mail.com”]
]

则有4个账户。

用哈希表建立<邮箱,账户1,…,账户x>的关联。

“johnsmith@mail.com” 0 1
“john_newyork@mail.com” 0
“john00@mail.com” 1
“mary@mail.com” 2
“johnnybravo@mail.com” 3

对账户建立并查集。同一个邮箱的账户属于同一类。

则分成三类：{0,1};{2};{3}。

将同一类的账户和邮箱收集即可。

[
[“John”,”john00@mail.com”,”john_newyork@mail.com”,”johnsmith@mail.com”],
[“Mary”,”mary@mail.com”],
[“John”,”johnnybravo@mail.com”]
]

```
整体思路：

hash<邮箱,账户1,...,账户x>;
P:并查集;
P[i] = i;
for([账户i,邮箱i1,...,邮箱it] in accounts){
    for(邮箱ij in [邮箱i1,...,邮箱it]){
        hash[邮箱ij] = [...] + 账户i;
    }
}
//合并同类
for(<邮箱ij,账户i,...账户u] in hash){
    for(账户x in [账户i,...账户u]){
        p1 = find(P,账户x);
        p2 = find(P,账户i);
        P[p1] = P2;
    }
}
将同一类账户的邮箱收集起来即可;
```



#### [@@@407. 接雨水 II](https://leetcode-cn.com/problems/trapping-rain-water-ii/)

```java
class Solution {
    public int trapRainWater(int[][] heights) {
        if (heights == null || heights.length == 0) return 0;
        int n = heights.length;
        int m = heights[0].length;
        // 用一个vis数组来标记这个位置有没有被访问过
        boolean[][] vis = new boolean[n][m];
        // 优先队列中存放三元组 [x,y,h] 坐标和高度
        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[2] - o2[2]);

        // 先把最外一圈放进去
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {
                    pq.offer(new int[]{i, j, heights[i][j]});
                    vis[i][j] = true;
                }
            }
        }
        int res = 0;
        // 方向数组，把dx和dy压缩成一维来
        int[] dirs = {-1, 0, 1, 0, -1};
        while (!pq.isEmpty()) {
            int[] poll = pq.poll();
            // 看一下四个方向
            for (int k = 0; k < 4; k++) {
                int nx = poll[0] + dirs[k];
                int ny = poll[1] + dirs[k + 1];
                // 如果位置合法且没访问过
                if (nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny]) {
                    // 如果外围这一圈中最小的比当前这个还高，那就说明能往里面灌水啊
                    if (poll[2] > heights[nx][ny]) {
                        res += poll[2] - heights[nx][ny];
                    }
                    // 如果灌水高度得是你灌水后的高度了，如果没灌水也要取高的
                    pq.offer(new int[]{nx, ny, Math.max(heights[nx][ny], poll[2])});
                    vis[nx][ny] = true;
                }
            }
        }
        return res;
    }
}

```





#### [@@@301. 删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)

```java
class Solution {
public:
    vector<string> ans;
    vector<string> removeInvalidParentheses(string s) {
        // 寻找不合法半边括号的个数
        int left=0;
        int right=0;
        for(char i:s){
            if(i=='('){
                left++;
            }
            if(i==')'){
                if(left>0)left--;
                else right++;
            }
        }
        // 深度优先遍历，寻找题解
        // left与right为需要删除的数量
        dfs(s, 0, left, right);
        
        return ans;
    }
    void dfs(string s, int st, int l, int r){
        if(l==0&&r==0){
            if(check(s)){
                ans.push_back(s);
            }
            return;
        }
        for(int i=st;i<s.size();i++){
             // 去重
            if(i-1>=st&&s[i]==s[i-1])continue;
            if(l>0&&s[i]=='('){
                dfs(s.substr(0, i)+s.substr(i+1, s.size()-i-1), i, l-1, r);
            }
            if(r>0&&s[i]==')'){
                dfs(s.substr(0, i)+s.substr(i+1, s.size()-i-1), i, l, r-1);
            }
        }
    }
    // 检验合法性
    bool check(string s){
        int cnt=0;
        for(char i:s){
            if(i=='('){
                cnt++;
            }
            if(i==')'){
                cnt--;
                if(cnt<0)return false;
            }
        }
        return cnt==0;
    }
};
```





















