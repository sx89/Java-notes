<!-- TOC -->

- [习惯问题:](#习惯问题)
- [测试用例](#测试用例)
- [交流](#交流)
- [[@253. 会议室 II](https://leetcode-cn.com/problems/meeting-rooms-ii/)](#253-会议室-iihttpsleetcode-cncomproblemsmeeting-rooms-ii)
- [[@443. 压缩字符串](https://leetcode-cn.com/problems/string-compression/)](#443-压缩字符串httpsleetcode-cncomproblemsstring-compression)
- [[1239. 串联字符串的最大长度](https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/)](#1239-串联字符串的最大长度httpsleetcode-cncomproblemsmaximum-length-of-a-concatenated-string-with-unique-characters)
- [[@@@@@297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)](#297-二叉树的序列化与反序列化httpsleetcode-cncomproblemsserialize-and-deserialize-binary-tree)
- [[103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)](#103-二叉树的锯齿形层次遍历httpsleetcode-cncomproblemsbinary-tree-zigzag-level-order-traversal)
- [[@151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)](#151-翻转字符串里的单词httpsleetcode-cncomproblemsreverse-words-in-a-string)
- [[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)](#24-两两交换链表中的节点httpsleetcode-cncomproblemsswap-nodes-in-pairs)
- [[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)](#25-k-个一组翻转链表httpsleetcode-cncomproblemsreverse-nodes-in-k-group)
- [[@@@@@10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)](#10-正则表达式匹配httpsleetcode-cncomproblemsregular-expression-matching)
- [[@8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)](#8-字符串转换整数-atoihttpsleetcode-cncomproblemsstring-to-integer-atoi)
- [[@235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)](#235-二叉搜索树的最近公共祖先httpsleetcode-cncomproblemslowest-common-ancestor-of-a-binary-search-tree)
- [[@236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)](#236-二叉树的最近公共祖先httpsleetcode-cncomproblemslowest-common-ancestor-of-a-binary-tree)
- [@循环节长度](#循环节长度)
- [两个数字字符串相加，区分正负](#两个数字字符串相加区分正负)
- [[419. 甲板上的战舰](https://leetcode-cn.com/problems/battleships-in-a-board/)](#419-甲板上的战舰httpsleetcode-cncomproblemsbattleships-in-a-board)
- [[@@398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)](#398-随机数索引httpsleetcode-cncomproblemsrandom-pick-index)
- [@@随机数的生成](#随机数的生成)
- [[面试题 16.11. 跳水板](https://leetcode-cn.com/problems/diving-board-lcci/)](#面试题-1611-跳水板httpsleetcode-cncomproblemsdiving-board-lcci)
- [[581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)](#581-最短无序连续子数组httpsleetcode-cncomproblemsshortest-unsorted-continuous-subarray)
- [[@@@93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)](#93-复原ip地址httpsleetcode-cncomproblemsrestore-ip-addresses)
- [[134. 加油站](https://leetcode-cn.com/problems/gas-station/)](#134-加油站httpsleetcode-cncomproblemsgas-station)
- [[@@@116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)](#116-填充每个节点的下一个右侧节点指针httpsleetcode-cncomproblemspopulating-next-right-pointers-in-each-node)
- [[@@@90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)](#90-子集-iihttpsleetcode-cncomproblemssubsets-ii)
- [[13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)](#13-罗马数字转整数httpsleetcode-cncomproblemsroman-to-integer)
- [[@348. 判定井字棋胜负](https://leetcode-cn.com/problems/design-tic-tac-toe/)](#348-判定井字棋胜负httpsleetcode-cncomproblemsdesign-tic-tac-toe)
- [[114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)](#114-二叉树展开为链表httpsleetcode-cncomproblemsflatten-binary-tree-to-linked-list)
- [[48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)](#48-旋转图像httpsleetcode-cncomproblemsrotate-image)
- [@连续子串=连续子序列!=子序列 ;](#连续子串连续子序列子序列-)
- [@@和0为的连续最长子序列(子串,和为k)](#和0为的连续最长子序列子串和为k)
- [@@最大长度的01连续子序列](#最大长度的01连续子序列)
- [全排列](#全排列)
- [012组合数](#012组合数)
- [求1到1000000的质数](#求1到1000000的质数)
- [三角形](#三角形)
- [链表相交的节点](#链表相交的节点)
- [@@@链表环入口](#链表环入口)
- [@@相亲数](#相亲数)
- [@@@@@@@@链表快排.](#链表快排)
- [[@@@@@148. 排序链表](https://leetcode-cn.com/problems/sort-list/)](#148-排序链表httpsleetcode-cncomproblemssort-list)

<!-- /TOC -->

#### 习惯问题:

先跟面试官沟通题目的意思

注意边界情况  判空, 单数双数,正负数,有相同重复数据(map,index),

写完后把代码规整起来

主动分析时间复杂度和空间复杂度

#### 测试用例

while(left<right)的循环内部,记得left++,right--

边界情况  

非法输入

判空,

单数双数

正负数

0的情况

定位角色混淆不明确.

有相同重复数据(map,index,非重复组合)

值溢出

输入输出不符合规范

矩阵是不是方阵

如果是直角三角形的时候，也有可能是等腰三角形；

计算直角三角形的时候，要考虑溢出。

#### 交流

**交流很重要，要互动(有没有负数,允不允许结果重复)**

注重**代码质量（编程风格、命名规范、异常值处理）**

各种**follow up**以及要你设计尽可能多的**测试用例**。



#### [@253. 会议室 II](https://leetcode-cn.com/problems/meeting-rooms-ii/)



```java


思路:startTime排序,每到一个startTime,usedRoom就+1.如果在该时间之前有结束的会议室(endTime[endPointer]<=startTime[startPointer]).usedRoom就-1;
public int minMeetingRooms(int[][] intervals) {
        int len = intervals.length;

        int max = 0;
        int[] startTime = new int[len];
        int[] endTime = new int[len];
        for (int i = 0; i < len; i++) {
            startTime[i] = intervals[i][0];
            endTime[i] = intervals[i][1];
        }
        Arrays.sort(startTime);
        Arrays.sort(endTime);
        int usedRooms = 0;
        int endPointer = 0;
        for (int startPointer = 0; startPointer < len; ) {
            if (endTime[endPointer] <= startTime[startPointer]) {
                usedRooms--;
                endPointer++;
            }
            usedRooms++;
            startPointer++;
        }
        return usedRooms;
    }
```



#### [@443. 压缩字符串](https://leetcode-cn.com/problems/string-compression/)



write read,chBegin的妙用

if (read == chars.length - 1 || chars[read] != chars[read + 1])  这两个条件很重要

```java
 public int compress(char[] chars) {
        int read = 0;
        int write = 0;
        int chBegin = 0;
        for (read = 0; read < chars.length; read++) {
            if (read == chars.length - 1 || chars[read] != chars[read + 1]) {
                int count = read - chBegin + 1;
                chars[write++] = chars[read];
                if (count >= 2) {
                    String temp = count + "";
                    for (int i = 0; i < temp.length(); i++) {
                        chars[write++] = temp.charAt(i);
                    }
                }
                chBegin = read + 1;
            }
        }
        return write;
    }
```



#### [1239. 串联字符串的最大长度](https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/)

回溯的题目,没啥好说的,熟练了

```java
int maxLen = 0;
    HashSet<Character> set = new HashSet<>();

    public int maxLength(List<String> arr) {
        bracktracing(arr, 0, 0);
        return maxLen;
    }

    private void bracktracing(List<String> arr, int index, int len) {
        if (index >= arr.size()) {
            return;
        }
        for (int i = index; i < arr.size(); i++) {
            String temp = arr.get(i);
            if (isUnique(temp)) {
                maxLen = Math.max(maxLen, len + temp.length());
                for (int j = 0; j < temp.length(); j++) {
                    set.add(temp.charAt(j));
                }

                bracktracing(arr, i + 1, len + temp.length());

                for (int j = 0; j < temp.length(); j++) {
                    set.remove(temp.charAt(j));
                }
            }
        }
    }

    private boolean isUnique(String temp) {
        for (int i = 0; i < temp.length(); i++) {
            if (set.contains(temp.charAt(i))) {
                int cutIndex = i;
                for (int j = 0; j < cutIndex; j++) {
                    set.remove(temp.charAt(j));
                }
                return false;
            } else {
                set.add(temp.charAt(i));
            }
        }
        return true;
    }
```



#### [@@@@@297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)



@为空返回#,左右子树用" "分隔开

@思路2 是错误的,  原因是 data是局部变量,而非全局变量,因为data是string类型,data的改变会被传入新的函数root.left = deserialize(data);但是当执行完root.left之后.回到root.right = deserialize(data); data的值不会受root.left的影响.

@序列出来的效果像这样:"1 2 # # 3 4 # # 5 # #"



```java
 //return "#"很关键
   String data = null;

    public String serialize(TreeNode root) {
        if (root == null) {
            return "#";
        }
        return root.val + " " + serialize(root.left) + " " + serialize(root.right);
    }

    public TreeNode deserialize(String str) {
        this.data = str;
        return deserialize();
    }

    private TreeNode deserialize() {
        if (data == null || data.length() == 0) {
            return null;
        }
        String rootValStr = null;
        int rootCutIndex = data.indexOf(" ");
		//切割rootValStr  
        if (rootCutIndex == -1) {
            rootValStr = data;
        } else {
            rootValStr = data.substring(0, rootCutIndex);
        }
		//切割剩余的Str
        if (rootCutIndex == -1) {
            data = "";
        } else {
            data = data.substring(rootCutIndex + 1);
        }
		//rootValStr作解析
        if (rootValStr.equals("#")) {
            return null;
        } else {
            TreeNode root = new TreeNode(Integer.parseInt(rootValStr));
            root.left = deserialize();
            root.right = deserialize();
            return root;
        }
    }



错误的反序列化方式:
错在data不是全局变量.
 public TreeNode deserialize2(String data) {
        if (data == null || data.length() == 0) {
            return null;
        }
        int cutIndex = 0;
        for (cutIndex = 0; cutIndex < data.length(); cutIndex++) {
            if (data.charAt(cutIndex) == ' ') {
                break;
            }
        }
        String rootVal = data.substring(0, cutIndex);
        if (cutIndex < data.length()) {
            data = data.substring(cutIndex + 1);
        } else {
            data = "";
        }
        if (rootVal.equals("#")) {
            return null;
        }
        TreeNode root = new TreeNode(Integer.parseInt(rootVal));
        root.left = deserialize(data);
        root.right = deserialize(data);
        return root;
    }

```





#### [103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)



```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    int level = 1;
    int count = 0;
    List<List<Integer>> ret = new ArrayList<>();
    if (root == null) {
        return ret;
    }
    count = 1;
    queue.add(root);
    while (!queue.isEmpty()) {
        List<Integer> list = new ArrayList<>();
        int tempCount = 0;
        for (int i = 0; i < count; i++) {
            TreeNode node = queue.poll();
            if (level % 2 == 0) {
                list.add(0, node.val);
            } else {
                list.add(node.val);
            }
            if (node.left != null) {
                queue.add(node.left);
                tempCount++;
            }
            if (node.right != null) {
                queue.add(node.right);
                tempCount++;
            }
        }
        level++;
        count = tempCount;
        ret.add(list);
    }
    return ret;
}
```



#### [@151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

@trim

@从后往前

@StringBuilder.append()  .deleter()  .length()



```java
public String reverseWords(String s) {
        s = s.trim();
        int len = s.length();
        StringBuilder ret = new StringBuilder();
        int wordEnd = len - 1;
        int read = len - 1;
        while (read >= 0) {
            while (read >= 0 && s.charAt(read) != ' ') {
                read--;
            }
            String temp = s.substring(read + 1, wordEnd + 1);
            //最后一个单词末尾不append " "
            if (read == -1) {
                ret.append(temp);
                return ret.toString();
            } else {
                ret.append(temp + " ");
            }
            while (read >= 0 && s.charAt(read) == ' ') {
                read--;
            }
            wordEnd = read;
        }
        return ret.toString();
    }
```





#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```java
 public ListNode swapPairs(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode pHead = new ListNode(-1);
        ListNode pNode = pHead;

        ListNode preNode = head;
        ListNode laterNode = head.next;

        while (preNode != null && laterNode != null) {
            ListNode temp = laterNode.next;
            //把laterNode插入
            laterNode.next = null;
            pNode.next = laterNode;
            pNode = pNode.next;
            //把preNode插入
            preNode.next = null;
            pNode.next = preNode;
            pNode = pNode.next;

            //pre 和 later都后移
            preNode = temp;
            if (temp != null) {
                laterNode = temp.next;
            }
        }
        //如果末尾还剩余一个节点,单独插入
        if (preNode != null) {
            preNode.next = null;
            pNode.next = preNode;
        }
        return pHead.next;
    }
```





#### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

@ k个一组,头插法翻转

@不需要先遍历k个一组是否满足k个,可以先翻转着,如果不满足k个,再翻转回来.

```

```





#### [@@@@@10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)





```
@为什么是 for (int i = 0; i < len1; i++) {
            for (int j = 0; j < len2; j++) {
            
 因为我dp[i][j]的含义是p的前j个字符串匹配  s的前i个.
 dp[i][j]需要用到 i-1,j-1  所以 for i  for j;
 
 而且用j在前,i在后也可以 
 for (int j = 0; j < len2; j++) {
 			for (int i = 0; i < len1; i++) {
            
 
 
```



```java


   public boolean isMatch(String s, String p) {
        if (s == null || p == null) {
            return false;
        }
        int len1 = s.length();
        int len2 = p.length();
        boolean[][] dp = new boolean[len1 + 1][len2 + 1];
        //边界的初始化.
        dp[0][0] = true;
        //初始化"" 与p的匹配关系      "" 和 a*a*a*是可以匹配的
        for (int j = 1; j <= len2; j++) {
            if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {
                dp[0][j] = true;
            }
        }
        //s不为空   p 为""  对应 dp[i][0] 全应为false

        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                // xxp   xxp     或     xxs    xx.
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p.charAt(j - 1) == '*') {
                    //两个i-1  两个 j-2
                    //xxp     xxp*    i-1  和  j-2   p*  匹配1个
                    //xxppp   xxp*    i-1 和  j   p* 匹配多个
                    // xxp    xxpp*  i  和 j-2   p*匹配0个
                    if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') {
                        dp[i][j] = dp[i - 1][j - 2] || dp[i - 1][j] || dp[i][j - 2];
                    } else {
                        // xx  要和  xxp*匹配   i  和  j-2   p*匹配0个
                        dp[i][j] = dp[i][j - 2];
                    }
                }
            }
        }
        return dp[len1][len2];
    }


```





#### [@8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

@trim前判空,trim完了要判断长度,防止越界

@

```
if(ret<littleLimit){
	return ....
}
if(ret==littleLimit){
	if(ret*10<limit+digit){
		return ...
	}
}
ret = ret*10-digit;
```



```java

public int myAtoi(String str) {
    	if(str==null){
        	return 0;
        }
        str = str.trim();
        if (str == null || str.length() == 0)
            return 0;
        int len = str.length();
        boolean isNegative = false;
        boolean firstSign = false;
        char[] chars = str.toCharArray();

        int limit = 0;//用正数最大值的相反数作限制
        if (chars[0] == '-') {
            isNegative = true;
            firstSign = true;
            limit = Integer.MIN_VALUE;
        } else if (chars[0] == '+') {
            isNegative = false;
            firstSign = true;
            limit = -Integer.MAX_VALUE;
        } else {
            isNegative = false;
            firstSign = false;
            limit = -Integer.MAX_VALUE;
        }

        int littleLimit = limit / 10;
        int digit = 0;
        int result = 0;
        for (int i = firstSign ? 1 : 0; i < len; i++) {
            if (!(chars[i] >= '0' && chars[i] <= '9'))
                break;
            digit = chars[i] - '0';
            if (result < littleLimit)
                return isNegative?Integer.MIN_VALUE:Integer.MAX_VALUE;
            if (result * 10 < limit + digit)
                //注意!!!!!!!改进!!!!!!
                //这里不可以写result*10-digit < limit  左边会越界,影响比较大小的真实逻辑
                return isNegative?Integer.MIN_VALUE:Integer.MAX_VALUE;
            result = result * 10 - digit;
        }
        return isNegative ? result : -result;
    }
    
```





#### [@235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

@二叉搜索树的特点是,找到第一个可以把p和q区分开的root.val,就是最近的root.val.

所以本题也不需要后序遍历.

```java
递归:起名有问题,其实不是后序遍历,从根往下走即可

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return null;
        }
        return lastOrder(root, p, q);
    }

    private TreeNode lastOrder(TreeNode root, TreeNode p, TreeNode q) {

        if (root.val > p.val && root.val > q.val) {
            return lastOrder(root.left, p, q);
        } else if (root.val < p.val && root.val < q.val) {
            return lastOrder(root.right, p, q);
        } else {
            return root;
        }
    }

非递归:也不是后序遍历,直接从根往下走即可

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null)
            return null;
        int pVal = p.val;
        int qVal = q.val;
        TreeNode node = root;
        while(node!=null){
            if(node.val>pVal&&node.val>qVal)
                node = node.left;
            else if(node.val<pVal&&node.val<qVal)
                node = node.right;
            else 
                return node;
        }
        return node;
    }

```



#### [@236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return preOrder(root, p, q);
    }

    private TreeNode preOrder(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return root;
        }
        if (root == p || root == q) {
            return root;
        }
        TreeNode left = preOrder(root.left, p, q);
        TreeNode right = preOrder(root.right, p, q);

        if (left != null && right != null) {
            return root;
        } else if (left == null && right == null) {
            return null;
        } else {
            return left == null ? right : left;
        }
    }
```



#### @循环节长度

两个整数做除法，有时会产生循环小数，其循环部分称为：循环节。 
比如，11/13=6=>0.846153846153….. 其循环节为[846153] 共有6位。 



https://blog.csdn.net/weixin_41514525/article/details/97121292

```java
思路:如果11/13 是循环的.那么将来的被除数中肯定还会出现11
private int getCyc(int n, int m) {
        if (m == 0) {
            return -1;
        }
        int remain = n % m;
        int remainFlag = remain;
        int count = 0;
        do {
            count++;
            remain = remain * 10 % m;
            if (remain == 0) {
                return -1;
            }
        } while (remain != remainFlag);
        return count;
    }


```





#### 两个数字字符串相加，区分正负



```

1.正负号另算,用大正数减去小正数 
2. 比如9887 - 92
3.  首位-1,   末位借10 ,  其他位都借9.
也就是8887 加上   99(10) -92
4.最后8887+ 908

```





#### [419. 甲板上的战舰](https://leetcode-cn.com/problems/battleships-in-a-board/)

```java
如果题设没有特殊规则和要求的话，常规做法就是使用BFS或者DFS扫描，计算连通图的个数。
但是题目要求只扫描一次，且O(1)的额外空间，那么就只能从题目给出的特殊规则出发了。
特殊规则：连通图是1xN或者Nx1的长条形的，且不会相交（之间有.分隔）。
解法：扫描到X时，如果上方或者左方也是X，则不计数，否则计数加1。

class Solution {
public:
    int countBattleships(vector<vector<char>>& board) {
        int nCount = 0;
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[i].size(); ++j) {
                if (board[i][j] == 'X') {
                    if (i > 0 && board[i - 1][j] == 'X' ||
                        j > 0 && board[i][j - 1] == 'X')
                        continue;
                    ++nCount;
                }
            }
        }
        return nCount;
    }
};

```



#### [@@398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)

**第k个数被选中的概率是  1/k.  前1~k-1个数平分 (k-1)/k的可能性(为什么? 用归纳推理可知, k=1时,概率为1,k=2时,两个元素概率为 1/2,1/2. k=3时,即为k的普遍情况.),所以最终每个元素都获得 1/k被选中的可能性.**



@@蓄水池抽样问题
首先从最简单的例子出发：数据流只有一个数据。我们接收数据，发现数据流结束了，直接返回该数据，该数据返回的概率为1。

看来很简单，那么我们试试难一点的情况：假设数据流里有两个数据。我们读到了第一个数据，这次我们不能直接返回该数据，因为数据流没有结束。我们继续读取第二个数据，发现数据流结束了。因此我们只要保证以相同的概率返回第一个或者第二个数据就可以满足题目要求。因此我们生成一个0到1的随机数R,如果R小于0.5我们就返回第一个数据，如果R大于0.5，返回第二个数据。

接着我们继续分析有三个数据的数据流的情况。为了方便，我们按顺序给流中的数据命名为1、2、3。我们陆续收到了数据1、2和前面的例子一样，我们只能保存一个数据，所以必须淘汰1和2中的一个。应该如何淘汰呢？不妨和上面例子一样，我们按照二分之一的概率淘汰一个，例如我们淘汰了2。继续读取流中的数据3，发现数据流结束了，我们知道在长度为3的数据流中，如果返回数据3的概率为1/3,那么才有可能保证选择的正确性。也就是说，目前我们手里有1,3两个数据，我们通过一次随机选择，以1/3的概率留下数据3，以2/3的概率留下数据1。那么数据1被最终留下的概率是多少呢？

数据1被留下：（1/2）(2/3) = 1/3
数据2被留下概率：（1/2）(2/3) = 1/3
数据3被留下概率：1/3

```java
 Random random = new Random();
int i = random.nextInt(100);


蓄水池抽样问题.

 private int[] nums = null;

    public Solution(int[] nums) {
        this.nums = nums;
    }

    public int pick(int target) {
        int ret = 0;
        int cnt = 0;
        Random r = new Random();
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                if (cnt == 0) {
                    cnt++;
                    ret = i;
                } else {
                    cnt++;
                    if (r.nextInt() % cnt == 0) {
                        ret = i;
                    }
                }
            }
        }
        return ret;
    }
```

#### @@随机数的生成



```java
Random函数的官方注释
random.nextInt(5);  0~4
//Returns a pseudorandom, uniformly distributed {@code int} value
//between 0 (inclusive) and the specified value (exclusive),
```



https://blog.csdn.net/wangruitao1991/article/details/51678815

已知rand5生成rand7.

1. 首先用  5*(rand5-1)生成  0  5 10 15...20

2. 再用  5*(rand5-1)+rand5  生成  1~25均匀整数

3. 因为7在25下的最大倍数是21,所以 如果步骤2里面生成的数字大于21,就重新生成,小于21就进行第4步

4. 1~21之间的数,用来%7, 求出0~6.  再+1 即可 1~7的随机分布.

```
int Rand7(){
    int x = ~(1<<31); // max int
    while(x > 21)
        x = 5 * (Rand5() - 1) + Rand5() // Rand25
    return x%7 + 1;
}
```



再比如用rand100生成rand150

```
int rand150(){
	int x = 0;
	x = 100* ( rand100() - 1 ) +rand100();
	//10000> 150*60=9900
	while(x>9900){
		x = 100* ( rand100() - 1 ) +rand100();
	}
	return x%150+1;
}
```





#### [面试题 16.11. 跳水板](https://leetcode-cn.com/problems/diving-board-lcci/)

@@@@注意 数组中的diff的次数是从0 到k

```java
public int[] divingBoard(int shorter, int longer, int k) {
    int diff = longer - shorter;

    if (k == 0) {
        return new int[0];
    }
    if (shorter == longer) {
        return new int[]{k * shorter};
    }
    //diff的个数是从0到k  所以是k+1
    int[] ret = new int[k + 1];
    for (int i = 0; i <= k; i++) {
        ret[i] = shorter * k + diff * i;
    }
    return ret;
}
```



#### [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)



@思想是无序子数组中最小元素的正确位置可以决定左边界，最大元素的正确位置可以决定右边界。



```java
public int findUnsortedSubarray(int[] nums) {
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        boolean flag = false;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < nums[i - 1]) {
                flag = true;
            }
            if (flag) {
                min = Math.min(min, nums[i]);
            }
        }
        flag = false;
        for (int i = nums.length - 2; i >= 0; i--) {
            if (nums[i] > nums[i + 1]) {
                flag = true;
            }
            if (flag) {
                max = Math.max(max, nums[i]);
            }
        }
        int start = 0;
        int end = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > min) {
                start = i;
                break;
            }
        }
        for (int i = nums.length - 1; i >= 0; i--) {
            if (nums[i] < max) {
                end = i;
                break;
            }
        }
        return start == end ? 0 : end - start + 1;
    }
作者：LeetCode
链接：https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/zui-duan-wu-xu-lian-xu-zi-shu-zu-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### [@@@93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

@StringBuilder用于回溯

@ip的条件  cutCount = 4, index==len,Integer.parseInt(temp)<=255,若temp.charAt(0)=='0'只能为一位0不能是001,012,08这种类型.

```java
  List<String> ret = new ArrayList<>();
    int len = 0;

    public List<String> restoreIpAddresses(String s) {
        len = s.length();
        backtracing(s, 0, 0, new StringBuilder());
        return ret;
    }

    private void backtracing(String s, int cutCount, int index, StringBuilder path) {
        if (index > len || cutCount > 4) {
            return;
        }
        if (index == len && cutCount == 4) {
            path.delete(path.length() - 1, path.length());
            ret.add(path.toString());
            path.append(".");
            return;
        }
        for (int j = index; j <= index + 3; j++) {
            String temp = "";
            if (j < len) {
                temp = s.substring(index, j + 1);
                if (s.charAt(index) == '0' && j == index) {
                    path.append(temp).append(".");
                    backtracing(s, cutCount + 1, j + 1, path);
                    path.delete(path.length() - temp.length() - 1, path.length());
                } else if (s.charAt(index) != '0' && Integer.parseInt(temp) <= 255) {
                    path.append(temp).append(".");
                    backtracing(s, cutCount + 1, j + 1, path);
                    path.delete(path.length() - temp.length() - 1, path.length());
                }
            }
        }
    }
```



#### [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

```java
 boolean finded = false;

    public int canCompleteCircuit(int[] gas, int[] cost) {
        for (int i = 0; i < gas.length; i++) {
            carRun(gas, cost, i);
            if (finded) {
                return i;
            }
        }
        return -1;
    }

    private void carRun(int[] gas, int[] cost, int begin) {
        int tank = 0;
        for (int i = begin; i < gas.length; i++) {
            tank += gas[i];
            tank -= cost[i];
            if (tank < 0) {
                return;
            }
        }
        for (int i = 0; i <= begin; i++) {
            tank += gas[i];
            tank -= cost[i];
            if (tank < 0) {
                return;
            }
        }
        finded = true;
    }
```



#### [@@@116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

@每个递归,负责连两条线.

@@@

  	Node next = root.next;
        if (right != null && next != null) {
            right.next = next.left;
        }



```java
public Node connect(Node root) {
        if (root == null) {
            return null;
        }
        Node left = root.left;
        Node right = root.right;
        if (left != null) {
            left.next = right;
        }

        Node next = root.next;
        if (right != null && next != null) {
            right.next = next.left;
        }

        connect(root.left);
        connect(root.right);
        return root;
    }
```



#### [@@@90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

@排序+第二次碰到相同的数字就跳过(注意是第二次碰到再跳过)比如 

1  2   2  3  

```java
 public List<List<Integer>> ret = null;
    int[] nums = null;

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        ret = new ArrayList<>();
        if (nums == null) {
            return ret;
        }
        this.nums = nums;
        Arrays.sort(nums);
        backtacing(0, new ArrayList<Integer>());
        return ret;
    }

    public void backtacing(int index, ArrayList<Integer> path) {
        if (index > nums.length) {
            return;
        }
        ret.add(new ArrayList<Integer>(path));
        for (int i = index; i < nums.length; i++) {
            while (i > index && i < nums.length && nums[i - 1] == nums[i]) {
                i++;
            }
            if (i < nums.length) {
                path.add(nums[i]);
                backtacing(i + 1, path);
                path.remove(path.size() - 1);
            }
        }

    }
```



#### [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)



@因为是3999以内,最大位就是M(千).另外需要注意的就是如果preNum<nowNum,则pre代表的是要减去的值.



通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/roman-to-integer
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```java
 public int romanToInt(String s) {
        int preNum = getValue(s.charAt(0));
        int num = 0;
        int sum = 0;
        for (int i = 1; i < s.length(); i++) {
            num = getValue(s.charAt(i));
            if (preNum < num) {
                sum -= preNum;
            } else {
                sum += preNum;
            }
            preNum = num;
        }
        sum += preNum;
        return sum;

    }

    private int getValue(char ch) {
        switch (ch) {
            case 'I':
                return 1;
            case 'V':
                return 5;
            case 'X':
                return 10;
            case 'L':
                return 50;
            case 'C':
                return 100;
            case 'D':
                return 500;
            case 'M':
                return 1000;
            default:
                return 0;
        }
    }
```



#### [@348. 判定井字棋胜负](https://leetcode-cn.com/problems/design-tic-tac-toe/)

@但是本题没有判断 同一个玩家在某个点处重复下棋的情况,当然题目中也没要求有这种判断.

@制造一个记录每行,每列的数组,和两个记录对角线棋子数的数字.

一旦某个计数满足len,就获胜了

```java
    int[] rowRem = null;
    int[] colRem = null;
    int diagnol = 0;
    int antiDiagnol = 0;
    int len = 0;

    public TicTacToe(int n) {
        len = n;
        rowRem = new int[n];
        colRem = new int[n];
    }

    public int move(int row, int col, int player) {
        int toAdd = player == 1 ? 1 : -1;
        rowRem[row] += toAdd;
        colRem[col] += toAdd;
        if (row == col) {
            diagnol += toAdd;
        }
        if (row + col == len - 1) {
            antiDiagnol += toAdd;
        }
        if (Math.abs(rowRem[row]) == len ||
                Math.abs(colRem[col]) == len ||
                Math.abs(diagnol) == len ||
                Math.abs(antiDiagnol) == len) {
            return player;
        }
        return 0;
    }
```







#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```java
 private TreeNode pre = null;

    public void flatten(TreeNode root) {
        preOrder(root);
    }

    private void preOrder(TreeNode root) {

        if (root == null) {
            return;
        }
        //需要提前把左右子树存储好
        TreeNode left = root.left;
        TreeNode right = root.right;
        if (pre != null) {
            pre.right = root;

        }
        pre = root;
        root.left = null;
        preOrder(left);
        preOrder(right);

    }
```


private TreeNode pre = null;

    public void flatten(TreeNode root) {
        preOrder(root);
    }
    
    private void preOrder(TreeNode root) {
    
        if (root == null) {
            return;
        }
        //需要提前把左右子树存储好
        TreeNode left = root.left;
        TreeNode right = root.right;
        if (pre != null) {
            pre.right = root;
    
        }
        pre = root;
        root.left = null;
        preOrder(left);
        preOrder(right);
    
    }



#### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

```java
 public void rotate(int[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = i + 1; j < matrix.length; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix.length / 2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.length - 1 - j];
                matrix[i][matrix.length - 1 - j] = temp;
            }
        }
    }
```





#### @连续子串=连续子序列!=子序列 ;

**子串可能用滑动窗口或者梯度**

**子序列可能是背包.但是也不绝对**



#### @@和0为的连续最长子序列(子串,和为k)

@**利用求和的梯度来做.**

```  
{3,0,-1,-2,-3,1,1,1,2,3,1,-2,-1}   12

{1，-1，1，-1，1，-1，1，-1}     8
```

```java
 public int func(int[] nums) {
        int maxLen = 0;
        int sum = 0;

        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, 0);
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (map.containsKey(sum)) {
                int len = i+1 - map.get(sum);
                maxLen = Math.max(len, maxLen);
            } else {
                map.put(sum, i+1);
            }
        }
        return maxLen;
    }
```





#### @@最大长度的01连续子序列

给定一个数组，数组中只包含0和1。请找到一个最长的子序列，其中0和1的数量是相同的



因为01数量要相同,可以把0转换成-1, 变成上面一道题"和为0的连续最长子序列"

而上一道题的做法就是利用梯度+hashmap存梯度索引



```java
 public int getMaxLen(int[] nums) {

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {
                nums[i] = -1;
            }
        }
        int maxLen = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        map.put(0, -1);
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            nums[i] = sum;
            if (map.containsKey(nums[i])) {
                int len = i - map.get(nums[i]);
                maxLen = Math.max(len, maxLen);
            } else {
                map.put(sum, i);
            }
        }
        return maxLen;
    }
```





#### 全排列

https://leetcode.com/problems/permutations/



```java
List<List<Integer>> ret = new ArrayList<>();
    boolean[] visited = null;
    int len = 0;
    ArrayList<Integer> path = new ArrayList<Integer>();

    public List<List<Integer>> permute(int[] nums) {
        if (nums == null || nums.length == 0) {
            return ret;
        }
        len = nums.length;
        visited = new boolean[len];
        for (int i = 0; i < len; i++) {
            path.add(nums[i]);
            visited[i] = true;
            backtracing(nums, i, path);
            visited[i] = false;
            path.remove(path.size() - 1);
        }
        return ret;

    }

    private void backtracing(int[] nums, int index, ArrayList<Integer> path) {

        if (path.size() == len) {
            ret.add(new ArrayList<Integer>(path));
            return;
        }
        for (int i = 0; i < len; i++) {
            if (visited[i] == false) {
                path.add(nums[i]);
                visited[i] = true;
                backtracing(nums, i, path);
                visited[i] = false;
                path.remove(path.size() - 1);
            }
        }
    }
```



#### 012组合数

一道是长度为N的数组，每个元素为0或1或2，找到满足a\[i\]&lt;a\[j\]&lt;a\[k\]的\(i, j, k\)的数量

```java
 public int func(int[] nums) {
        int[][] remember = new int[nums.length][2];
        int countZero = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i == 0) {
                remember[i][0] = 0;
            } else {
                remember[i][0] = countZero;
            }

            if (nums[i] == 0) {
                countZero++;
            }
        }
        int countTwo = 0;
        for (int i = nums.length - 1; i >= 0; i--) {
            if (i == nums.length - 1) {
                remember[i][1] = 0;
            } else {
                remember[i][1] = countTwo;
            }

            if (nums[i] == 2) {
                countTwo++;
            }
        }
        int ret = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1) {
                ret += remember[i][0] * remember[i][1];
            }
        }
        return ret;
    }
```

#### 求1到1000000的质数

```
先假设所有数都是素数,如果4不是素数,则 4的所有倍数都不是素数.
不需要再写判断一个数是否是素数的函数.因为比如比7小的数无法将7排除,则7一定是素数.
```

#### 三角形

```
判断三个数能否形成三角形，要求实现isTriangle\(int a, int b, int c\)
  
只能判断相减是否小于，不能用两边之和大于第三边，会溢出
```

####   链表相交的节点

```
断两个链表是否相交是求链表是否存在环的变式，如给定两个链表A和B

* A遍历自己，一直到终点再从B开始。B也如此，遍历完自己再遍历A。
* 如果中间有相同节点了，那么就相交，否则不相交。
* 因为如果相交的话，那么都会走到len\(A\)+len\(B\)-len\(A∩B\)的地方停下来
```



#### @@@链表环入口

https://leetcode.com/problems/linked-list-cycle-ii/submissions/

@第一步  先  快指针 2个  慢指针1个  再 判断是否相遇

@第二步 快指针和慢指针都1个    在判断是否相遇.

@ if (fast != null && fast == slow)     fast==slow  == null  是一种没有环的情况,此时fast没必要赋值为head了

```java
public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }

        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && slow != null) {
            fast = fast.next;
            if (fast != null) {
                fast = fast.next;
            }
            slow = slow.next;
            //fast判空
            if (fast != null && fast == slow) {
                fast = head;
                break;
            }
        }

        while (fast != null && slow != null) {
            if (fast == slow) {
                return fast;
            }
            //第二次循环是每人走一步.
            fast = fast.next;
            slow = slow.next;
        }
        return fast;
    }
```





#### @@相亲数

amicable number, 两个正整数中，彼此的全部正约数之和与另一方相等

* 约数又叫因数，b是a的约数，则a%b==0，整除没有余数
* 220的所有因子\(除了自己以外的因子\)：1+2+4+5+10+11+20+22+44+55+110 = 284
* 284的所有因子：1+2+4+71+142 = 220

给出maxNum,求出0~maxNum的相亲数



@约的求解1.边界是`i*i<=num   2.i*i==num的时候只算一个i    `

@相亲数的寻找  i= 220  sum[i] = 284  sum[284] = 220  所以  sum[sum[i]] = i. 并且要注意 i= 6; sum[6]=6这种特殊情况 

```java
 private int getSum(int num) {
        int sum = 0;
        for (int i = 1; i * i <= num; i++) {

            //i的三种特殊情况  假设num为100, i=10的时候只算一个10
            //i=1的时候  不加 100/1
            //其他时候 如果num%i==0   比如 i=2   则 2和50都加到sum里
            if (i * i == num) {
                return sum + i;
            }
            if (i == 1) {
                sum += 1;
                continue;
            }
            if (num % i == 0) {
                sum += i;
                sum += num / i;
            }
        }

        return sum;
    }

    public ArrayList<Integer> getAllNum(int maxNum) {
        ArrayList<Integer> ret = new ArrayList<>();
        int[] sum = new int[maxNum + 1];
        for (int i = 2; i <= maxNum; i++) {
            sum[i] = getSum(i);
        }
        for (int i = 2; i <= maxNum; i++) {
            if (sum[i] > maxNum) {
                continue;
            }
            if (sum[i] != i && sum[sum[i]] == i) {
                ret.add(i);
            }
        }
        return ret;
    }
```



#### @@@@@@@@链表快排.

```java
 public void listQuickSort(ListNode pHead) {
        quickSort(pHead, null);
    }

    public void quickSort(ListNode pHead, ListNode pEnd) {
        if (pHead == null || pHead == pEnd) {
            return;
        }
        ListNode mid = partition(pHead, pEnd);
        quickSort(pHead, mid);
        quickSort(mid.next, null);
    }

    private ListNode partition(ListNode start, ListNode end) {
        if (start == null) {
            return null;
        }
        if (start.next == end) {
            return start;
        }
        ListNode preOfSwapNum = start;
        int key = start.val;
        ListNode node = start.next;
        while (node != end) {
            if (node.val <= key) {
                preOfSwapNum = preOfSwapNum.next;
                swap(preOfSwapNum, node);
            }
            node = node.next;
        }
        swap(preOfSwapNum, start);
        return preOfSwapNum;
    }

    private void swap(ListNode p1, ListNode p2) {
        int temp = p1.val;
        p1.val = p2.val;
        p2.val = temp;
    }

    private ListNode forTestInitialNodeList(int[] nums) {
        ListNode pHead = new ListNode(-1);
        ListNode node = pHead;
        for (int temp : nums) {
            node.next = new ListNode(temp);
            node = node.next;
        }
        return pHead.next;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        ListNode node = solution.forTestInitialNodeList(new int[]{2, 1});
        solution.listQuickSort(node);
        while (node != null) {
            System.out.println(node.val);
            node = node.next;
        }
    }
```





#### [@@@@@148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

@归并排序,需要截断list

@快速排序

```java
归并排序:
public ListNode sortList(ListNode head) {
        int len = 0;
        ListNode temp = head;
        while (head != null) {
            head = head.next;
            len++;
        }
        return mergeSort(temp, null, len);
    }

    private ListNode mergeSort(ListNode begin, ListNode end, int len) {
        if (begin == null || begin == end) {
            return begin;
        }

        int mid = len / 2;
        ListNode midNode = begin;
        int cnt = 1;
        while (cnt < mid) {
            cnt++;
            midNode = midNode.next;
        }

        ListNode begin2 = midNode.next;
        //记得把midNode截断这样l1和l2才是两段独立的链表.
        midNode.next = null;
        if (end != null) {
            end.next = null;
        }
        ListNode l1 = mergeSort(begin, midNode, mid);
        ListNode l2 = mergeSort(begin2, end, mid);
        return merge(l1, l2);
    }

    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(-1);
        ListNode node = head;
        if (l1 != null && l2 != null) {
            while (l1 != null && l2 != null) {
                if (l1.val <= l2.val) {
                    node.next = l1;
                    l1 = l1.next;
                } else {
                    node.next = l2;
                    l2 = l2.next;
                }
                node = node.next;
            }
            while (l1 != null) {
                node.next = l1;
                l1 = l1.next;
                node = node.next;
            }
            while (l2 != null) {
                node.next = l2;
                l2 = l2.next;
                node = node.next;
            }
            return head.next;
        } else if (l2 != null) {
            return l2;
        } else {
            return l1;
        }
    }


快速排序:

public ListNode sortList(ListNode head) {
        quickSort(head, null);
        return head;
    }

    private void quickSort(ListNode begin, ListNode end) {
        if (begin == null || begin == end) {
            return;
        }
        ListNode midNode = partition(begin, end);
        quickSort(begin, midNode);
        quickSort(midNode.next, end);
    }

    private ListNode partition(ListNode begin, ListNode end) {
        if (begin == null || begin == end) {
            return begin;
        }
        ListNode itsNextIsRightNum = begin;
        int key = begin.val;
        ListNode node = begin.next;
        while (node != end) {
            if (node.val <= key) {
                itsNextIsRightNum = itsNextIsRightNum.next;
                swap(itsNextIsRightNum, node);
            }
            node = node.next;
        }
        swap(itsNextIsRightNum, begin);
        return itsNextIsRightNum;
    }

    private void swap(ListNode p1, ListNode p2) {
        int temp = p1.val;
        p1.val = p2.val;
        p2.val = temp;
    }
```



