# Hbase基础

## 分布式知识

### 负载均衡

#### 负载均衡-客户端决定访问机器

客户端访问注册中心,拿到所有节点信息,由客户端决定访问那一个实例

<img src="pictures/Hbase/image-20200425092817308.png" alt="image-20200425092817308" style="zoom:50%;" />

#### 负载均衡-去中心化

redis中不存在注册中心,访问redis的任意节点就可以知道其他节点的信息,

## Hbase的特点

**1海量存储**

Hbase适合存储PB级别的海量数据，在PB级别的数据以及采用廉价PC存储的情况下，能在几十到百毫秒内返回数据。这与Hbase的极易扩展性息息相关。正式因为Hbase良好的扩展性，才为海量数据的存储提供了便利。

**2列式存储**

这里的列式存储其实说的是列族存储，Hbase是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。

**3极易扩展**

Hbase的扩展性主要体现在两个方面，一个是基于上层处理能力（RegionServer）的扩展，一个是基于存储的扩展（HDFS）。
 通过横向添加RegionSever的机器，进行水平扩展，提升Hbase上层的处理能力，提升Hbsae服务更多Region的能力。

备注：RegionServer的作用是管理region、承接业务的访问，这个后面会详细的介绍通过横向添加Datanode的机器，进行存储层扩容，提升Hbase的数据存储能力和提升后端存储的读写能力。

**4高并发**

由于目前大部分使用Hbase的架构，都是采用的廉价PC，因此单个IO的延迟其实并不小，一般在几十到上百ms之间。这里说的高并发，主要是在并发的情况下，Hbase的单个IO延迟下降并不多。能获得高并发、低延迟的服务。

**5稀疏**

稀疏主要是针对Hbase列的灵活性，在列族中，你可以指定任意多的列，在列数据为空的情况下，是不会占用存储空间的。相对应的是密集表,比如mysql的表,即使某个cell内容为空,它依然占内存,但hbase为空的地方不占内存.



## Hbase原理

### mysql的水平垂直切分  与 列的动态扩展

#### 一条查询语句,mysql是从左向右查,oracle是从右向左查.

如果是select * from user_info where sex = "女" and old = 20;从左向右查的效率低,因为性别属性的区分度不高,会筛选出一半的数据来,再筛选年龄.

#### 宽表与高表

mysql是以行为单位,所以面临属性较多的宽表,应该做水平拆分

日志类的高表,应该做水平拆分.

#### 列的动态扩展

列动态扩展可以用某一列存json数据,再解析的办法:

<img src="pictures/Hbase/image-20200425094428693.png" alt="image-20200425094428693" style="zoom:50%;" />



#### mysql的弊端

mysql的存储引擎InnoDB ,当命名空间中所有表的数据上限达到64T,性能将大幅度下降

Isam 单表256T后 性能大幅度下降

### Hbase的解决方法

<img src="pictures/Hbase/image-20200425095259032.png" alt="image-20200425095259032" style="zoom:50%;" />

#### 列拆分:

列族信息用json来存储,然后把列拆成很多列族,比如basic列族下几个列,info下几个列

#### 行拆分:

水平拆分

#### 加缓存:

(**读写都放入缓存,交给缓存来异步入库**,因为写入的数据极大可能马上读取,所以不写入hbase,而是写入缓存)

为了防止缓存宕机,写入数据丢失,还要使用**顺序写入**来做**持久化**

<img src="pictures/Hbase/image-20200425112841870.png" alt="image-20200425112841870" style="zoom:50%;" />

#### 零拷贝:

<img src="pictures/Hbase/image-20200425111114288.png" alt="image-20200425111114288" style="zoom:50%;" />

#### Kafka的吞吐量高的原因:顺序写入+零拷贝+分段日志

00001.log  00001.index

01000.log   00010.index  log是分段日志,index对应日志文件里面,某一条数据所在的位置. 第1256条数据在01000.log里面,index则告诉了它在01000.log的哪个位置上.